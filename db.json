{"meta":{"version":1,"warehouse":"1.0.1"},"models":{"Asset":[{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":1},{"_id":"themes/jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1},{"_id":"themes/jacman/source/img/author.jpg","path":"img/author.jpg","modified":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"source/images/数组排序/20150721.png","path":"images/数组排序/20150721.png","modified":1},{"_id":"source/images/手写UIButton/20150812.png","path":"images/手写UIButton/20150812.png","modified":1},{"_id":"source/images/pch/2.png","path":"images/pch/2.png","modified":1},{"_id":"source/images/pch/1.png","path":"images/pch/1.png","modified":1},{"_id":"source/images/ViewController/2.png","path":"images/ViewController/2.png","modified":1},{"_id":"source/images/ViewController/1.png","path":"images/ViewController/1.png","modified":1},{"_id":"source/images/UINavigationVC/9.png","path":"images/UINavigationVC/9.png","modified":1},{"_id":"source/images/UINavigationVC/8.png","path":"images/UINavigationVC/8.png","modified":1},{"_id":"source/images/UINavigationVC/7.png","path":"images/UINavigationVC/7.png","modified":1},{"_id":"source/images/UINavigationVC/6.png","path":"images/UINavigationVC/6.png","modified":1},{"_id":"source/images/UINavigationVC/5.png","path":"images/UINavigationVC/5.png","modified":1},{"_id":"source/images/UINavigationVC/4.png","path":"images/UINavigationVC/4.png","modified":1},{"_id":"source/images/UINavigationVC/3.png","path":"images/UINavigationVC/3.png","modified":1},{"_id":"source/images/UINavigationVC/2.png","path":"images/UINavigationVC/2.png","modified":1},{"_id":"source/images/UINavigationVC/14.png","path":"images/UINavigationVC/14.png","modified":1},{"_id":"source/images/UINavigationVC/13.png","path":"images/UINavigationVC/13.png","modified":1},{"_id":"source/images/UINavigationVC/12.png","path":"images/UINavigationVC/12.png","modified":1},{"_id":"source/images/UINavigationVC/11.png","path":"images/UINavigationVC/11.png","modified":1},{"_id":"source/images/UINavigationVC/10.png","path":"images/UINavigationVC/10.png","modified":1},{"_id":"source/images/UINavigationVC/1.png","path":"images/UINavigationVC/1.png","modified":1},{"_id":"source/images/Quartz2D/curve.png","path":"images/Quartz2D/curve.png","modified":1},{"_id":"source/images/Quartz2D/bezierpath.png","path":"images/Quartz2D/bezierpath.png","modified":1},{"_id":"source/images/Quartz2D/arrowWithGradient.png","path":"images/Quartz2D/arrowWithGradient.png","modified":1},{"_id":"source/images/Quartz2D/Rect.png","path":"images/Quartz2D/Rect.png","modified":1},{"_id":"source/images/Quartz2D/Line.png","path":"images/Quartz2D/Line.png","modified":1},{"_id":"source/images/Quartz2D/Arc.png","path":"images/Quartz2D/Arc.png","modified":1}],"Cache":[{"_id":"source/_posts/CocoaPods-下载和安装.md","shasum":"4a439e9505db3d308c7070b25ea1520f4b8e9647","modified":1452909582000},{"_id":"source/_posts/Hexo——搭建博客.md","shasum":"37cd37c823c01c38599ac29cdff0a3eee6f54aec","modified":1452909582000},{"_id":"source/_posts/OC数组排序.md","shasum":"ceb6573cd3348f57e8cd7e8d2faf3a9acf6eceaa","modified":1452909582000},{"_id":"source/_posts/SVN常用命令集合.md","shasum":"d1f089d8ce29052274bfbd763b5bd551656ac986","modified":1452909582000},{"_id":"source/_posts/UIButton控件设置.md","shasum":"eeaf29f0e87379721296f21fb6cb83e7bbdb4e62","modified":1452909582000},{"_id":"source/_posts/UINavigationController详解与使用（一）添加UIButtonItem.md","shasum":"1dada40a1b74fef0782b9ee75b1c11a98c333dda","modified":1452909582000},{"_id":"source/_posts/UINavigationController详解与使用（二）页面切换及ToolBar.md","shasum":"52623da2322a8da7472dd04848b5d31f9014bc2c","modified":1452909582000},{"_id":"source/_posts/XML-JSON.md","shasum":"71b25188397e187da364f6afecb7ba714803001b","modified":1452909582000},{"_id":"source/_posts/Xcode已安装插件的删除.md","shasum":"801f62e445bad0105dbffc659140a3529fc42f25","modified":1452909582000},{"_id":"source/_posts/iOS-Pch文件的使用.md","shasum":"81ce6cd53a9cbc0e1a0649cc135fef69bf2ae699","modified":1452909582000},{"_id":"source/_posts/iOS——ViewController生命周期.md","shasum":"8e0e25ac10f2e4bbf4204d77f6b9f8b368123158","modified":1452909582000},{"_id":"source/_posts/iOS学习-Quartz2D使用.md","shasum":"f64e3f861dfcea6bc3548d2b7849dab0e5a02f2d","modified":1452909582000},{"_id":"source/_posts/iOS开发——MD5加密算法.md","shasum":"e9b9bb45241cbbeb05968f6ed42a0b9fa3f18bd2","modified":1452909582000},{"_id":"source/_posts/手写代码UIButton图片和文字位置的设置.md","shasum":"46e02ac4aafa5ba1467ef743aac73bee69916a90","modified":1452909582000},{"_id":"source/_posts/迎着缺陷奔跑.md","shasum":"2e81faafb9990a1dbd79a1bc16d7d2c6cd56ab5d","modified":1452909582000},{"_id":"source/_posts/面相对象思想——个人理解.md","shasum":"29e0523aa134b9deda6095eda848414aab4f25e5","modified":1452909582000},{"_id":"source/images/Quartz2D/Arc.png","shasum":"567ef538e2b7c7c53f41263bff1a69df6f10a38a","modified":1452909582000},{"_id":"source/images/Quartz2D/Line.png","shasum":"aa5c127a3cbce15546d5d764e8e2598edf3186a6","modified":1452909582000},{"_id":"source/images/Quartz2D/Rect.png","shasum":"61db7c2a540687b307558590e55cb4dbfdc7d122","modified":1452909582000},{"_id":"source/images/Quartz2D/arrowWithGradient.png","shasum":"4526ac0f543d12f15b9865691bd3a2b301341b35","modified":1452909582000},{"_id":"source/images/Quartz2D/bezierpath.png","shasum":"ea9be78d757bee908de967c0975c5fd245edb45b","modified":1452909582000},{"_id":"source/images/Quartz2D/curve.png","shasum":"eaeaeef5deb90817ae8688d529a17d34fa2c5257","modified":1452909582000},{"_id":"source/images/UINavigationVC/11.png","shasum":"26d4622a888e36ecdaba21f669e8cbb29592023a","modified":1452909582000},{"_id":"source/images/UINavigationVC/7.png","shasum":"e3f75a70f0a15698289cef87e12f588e5139dddb","modified":1452909582000},{"_id":"source/images/UINavigationVC/9.png","shasum":"4842dbd265b3f143c1b5738a1daab558b39e34cb","modified":1452909582000},{"_id":"source/images/ViewController/1.png","shasum":"a37be3e93e03356d31ea743649f32a8d1670a4d9","modified":1452909582000},{"_id":"source/images/ViewController/2.png","shasum":"06fad2574ccb316f19d67c3ff54ce94aa48eda4c","modified":1452909582000},{"_id":"source/images/手写UIButton/20150812.png","shasum":"6b958e4deb9dd8ae54b7a8e5f49df152b1850799","modified":1452909582000},{"_id":"source/images/数组排序/20150721.png","shasum":"2cdb93ca9ab6c0a43de9f95541428ee4aca4aba2","modified":1452909582000},{"_id":"source/images/UINavigationVC/1.png","shasum":"76f3ee687032e98b0f64e1571453e6f2b0cf3e99","modified":1452909582000},{"_id":"source/images/UINavigationVC/12.png","shasum":"d7f9c9b2c5d8e4858fa1ae3ed46fa043bd0f4c20","modified":1452909582000},{"_id":"source/images/UINavigationVC/14.png","shasum":"de0d2f23951c057f0cccf34a8ab080007c0c27a9","modified":1452909582000},{"_id":"source/images/UINavigationVC/13.png","shasum":"4d5218d89af3dbdcdd502553bf36376b9ce86cf5","modified":1452909582000},{"_id":"source/images/UINavigationVC/6.png","shasum":"df6015267f964f986e81e05ddbad79c51dbdb270","modified":1452909582000},{"_id":"source/images/UINavigationVC/5.png","shasum":"6d7ca427820b25ccb8fa718ee8faddf402a9eb7a","modified":1452909582000},{"_id":"source/images/UINavigationVC/8.png","shasum":"6171819558138d9b8d2f4047047989a81f546619","modified":1452909582000},{"_id":"source/images/pch/1.png","shasum":"ae561bef149692def38ee36dfad98bcddb61794d","modified":1452909582000},{"_id":"source/images/UINavigationVC/10.png","shasum":"6a5fda96768b7a7162c591f54f01fb8b1da99fe6","modified":1452909582000},{"_id":"source/images/UINavigationVC/3.png","shasum":"668c5018f87b752d86e1c99ebf855e402156a55a","modified":1452909582000},{"_id":"source/images/pch/2.png","shasum":"8005621d497151d493403b71057d4224a11fcf5a","modified":1452909582000},{"_id":"source/images/UINavigationVC/2.png","shasum":"39f4a0dfca4db89c9ebde522acc45ab41625103d","modified":1452909582000},{"_id":"source/images/UINavigationVC/4.png","shasum":"c664c3a816b348afc59cd6d83fab7b457d94a82a","modified":1452909582000},{"_id":"themes/jacman/LICENSE","shasum":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1452909582000},{"_id":"themes/jacman/README.md","shasum":"38698c732ca2c0fa48de89cfee9859bc09e74fd4","modified":1452909582000},{"_id":"themes/jacman/README_zh.md","shasum":"ee9eeb2b72e5597a3550d59d231f443d990d3115","modified":1452909582000},{"_id":"themes/jacman/_config.yml","shasum":"617df9a7ebc2cc3093f07e434e2fab390559f8eb","modified":1452909582000},{"_id":"themes/jacman/_config.yml~","shasum":"182bf9809b497d7d29c1e1c96e6b1c3006cb2d41","modified":1452909582000},{"_id":"themes/jacman/languages/default.yml","shasum":"ad0de3e82c7fc238cc067ffc37359b1420aef6b3","modified":1452909582000},{"_id":"themes/jacman/languages/zh-CN.yml","shasum":"5e4ac19d7b2bbf0d5b5aa55d33653380abda8b9a","modified":1452909582000},{"_id":"themes/jacman/languages/zh-TW.yml","shasum":"41c112162d79b4d3f97b417c7cd6ca6d70419ef2","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","shasum":"37acd134f67b5be66740ac3d440f7888f49fde66","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","shasum":"fd004beb8d4500afd5fb3b3871a95afa2a375f16","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/archive.ejs","shasum":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/article.ejs","shasum":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","shasum":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/categories.ejs","shasum":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/footer.ejs","shasum":"03729b47a088ad4e118cde340ace620727da33c7","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/head.ejs","shasum":"cfb1f091bf4c0312f73835d846787156f0e011dc","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/header.ejs","shasum":"ce5a0cbb501af140e617e960dd6310d1627de1ba","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","shasum":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","shasum":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","shasum":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","shasum":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","shasum":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","shasum":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","shasum":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","shasum":"6d789715314a00915dc4518f8a0a6d4205ab6fd3","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","shasum":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","shasum":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/search.ejs","shasum":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","shasum":"c4f527fff0070fbe65919053a16224412317f40d","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/tags.ejs","shasum":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","shasum":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1452909582000},{"_id":"themes/jacman/layout/_partial/totop.ejs","shasum":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1452909582000},{"_id":"themes/jacman/layout/_widget/archive.ejs","shasum":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1452909582000},{"_id":"themes/jacman/layout/_widget/category.ejs","shasum":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1452909582000},{"_id":"themes/jacman/layout/_widget/douban.ejs","shasum":"94ce1fb7a1143f34ac1365924b00cae64e1a111e","modified":1452909582000},{"_id":"themes/jacman/layout/_widget/links.ejs","shasum":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1452909582000},{"_id":"themes/jacman/layout/_widget/rss.ejs","shasum":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1452909582000},{"_id":"themes/jacman/layout/_widget/tag.ejs","shasum":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1452909582000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","shasum":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1452909582000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","shasum":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1452909582000},{"_id":"themes/jacman/layout/archive.ejs","shasum":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1452909582000},{"_id":"themes/jacman/layout/category.ejs","shasum":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1452909582000},{"_id":"themes/jacman/layout/index.ejs","shasum":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1452909582000},{"_id":"themes/jacman/layout/layout.ejs","shasum":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1452909582000},{"_id":"themes/jacman/layout/page.ejs","shasum":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1452909582000},{"_id":"themes/jacman/layout/post.ejs","shasum":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1452909582000},{"_id":"themes/jacman/layout/tag.ejs","shasum":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1452909582000},{"_id":"themes/jacman/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1452909582000},{"_id":"themes/jacman/source/css/_base/code.styl","shasum":"a7fe002222bfc7a125c8fe92b26ba9dc604595a2","modified":1452909582000},{"_id":"themes/jacman/source/css/_base/font.styl","shasum":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1452909582000},{"_id":"themes/jacman/source/css/_base/public.styl","shasum":"a29e4a4fbc288323b7f3ca2e501a6609e5646e2f","modified":1452909582000},{"_id":"themes/jacman/source/css/_base/variable.styl","shasum":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1452909582000},{"_id":"themes/jacman/source/css/_partial/article.styl","shasum":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1452909582000},{"_id":"themes/jacman/source/css/_partial/aside.styl","shasum":"6b0e46e2e3be200339197696f5aabd0871aa9952","modified":1452909582000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","shasum":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1452909582000},{"_id":"themes/jacman/source/css/_partial/footer.styl","shasum":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1452909582000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","shasum":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1452909582000},{"_id":"themes/jacman/source/css/_partial/header.styl","shasum":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1452909582000},{"_id":"themes/jacman/source/css/_partial/helper.styl","shasum":"0bf862a860c07aff5f440b5e6f040baa83031d2c","modified":1452909582000},{"_id":"themes/jacman/source/css/_partial/index.styl","shasum":"864fba1fcb3830a9055c366a99ce5c951c2e9fe9","modified":1452909582000},{"_id":"themes/jacman/source/css/_partial/totop.styl","shasum":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1452909582000},{"_id":"themes/jacman/source/css/style.styl","shasum":"89070fcce9a70c82ea5559ae8f6efc60e624c6d3","modified":1452909582000},{"_id":"themes/jacman/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1452909582000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1452909582000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1452909582000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1452909582000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1452909582000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1452909582000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1452909582000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1452909582000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1452909582000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1452909582000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1452909582000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1452909582000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1452909582000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1452909582000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1452909582000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1452909582000},{"_id":"themes/jacman/source/font/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1452909582000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1452909582000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","shasum":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1452909582000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1452909582000},{"_id":"themes/jacman/source/font/fontdiao.eot","shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1452909582000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1452909582000},{"_id":"themes/jacman/source/font/fontdiao.woff","shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1452909582000},{"_id":"themes/jacman/source/font/fontdiao.ttf","shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1452909582000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1452909582000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1452909582000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1452909582000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1452909582000},{"_id":"themes/jacman/source/img/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1452909582000},{"_id":"themes/jacman/source/img/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1452909582000},{"_id":"themes/jacman/source/img/jacman.jpg","shasum":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1452909582000},{"_id":"themes/jacman/source/img/favicon.ico","shasum":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1452909582000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1452909582000},{"_id":"themes/jacman/source/img/scrollup.png","shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1452909582000},{"_id":"themes/jacman/source/img/logo.svg","shasum":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1452909582000},{"_id":"themes/jacman/source/js/gallery.js","shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1452909582000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1452909582000},{"_id":"themes/jacman/source/js/totop.js","shasum":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1452909582000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1452909582000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1452909582000},{"_id":"themes/jacman/source/font/fontdiao.svg","shasum":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1452909582000},{"_id":"themes/jacman/source/img/author.jpg","shasum":"6cec5253f7e7d3fe1fd8bde31ff708ea16eaec4b","modified":1452909582000},{"_id":"themes/jacman/source/img/logo.png","shasum":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1452909582000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1452909582000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1452909582000},{"_id":"themes/jacman/source/img/banner.jpg","shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1452909582000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"CocoaPods 下载和安装","date":"2014-05-25T07:02:45.000Z","_content":"\n###下载和安装\n\n\t在安装之前，首先要在本地安装好Ruby环境。如果你在本地已经安装好Ruby环境，那么下载和安装CocoaPods将十分简单，只需要一行命令。在终端中输入如下命令\n\t```\n\tsudo gem install cocoapods\n\t```\n\t但是，如果你在天朝，在终端中敲入这个命令之后，会发现半天没有任何反应。原因无他，因为那堵墙阻挡了cocoapods.org。我们可以用淘宝的Ruby镜像来访问cocoapods。按照下面的顺序在终端中依次敲入命令：\n\t```\n\tgem source --remove https://rubygems.org/\n\tgem source -a http://ruby.taobao.org/\n\t```\n\t为了验证你的Ruby镜像是并且仅是taobao，可以用一下命令查看：\n\t```\n\tgem source -l\n\t```\n\t只有在终端中出现下面文字才表明你上面的命令是成功的：\n\t```\n\t*** CURRENT SOURCES ***\n\thttp://ruby.taobao.org/\n\t```\n\t此时，你再次在终端中运行：\n\t```\n\tsudo gem install cocoapods\n\t```\n\t\n###使用CocoaPods\n\n\t安装好之后就是如何使用它了。我们以AFNetworking来说明吧\n\tAFNetworking类库在Github地址是:(https://github.com/AFNetworking/AFNetworking)\n\t为了确定AFnetworking是否支持Cocoapods，可以用Cocoapods的搜索功能验证一下。在终端中输入：\n\t```\n\tpod search AFnetworking\n\t```\n\t随后你会看到相关信息，准备工作也差不多了，下面让我们进入正题\n\t首先先利用Xcode创建一个项目工程。随后在终端中进入所创建的项目文件中，然后运行：\n\t```\n\tpod init\n\t```\n\t随后cocoapods会为项目自动生成一个Podfile文件，执行：\n\t```\n\tvim Podfile\n\t```\n\t然后再Podfile文件中target和end之间输入以下信息：\n\t```\n\tplatform :ios, '7.0'\n\tpod \"AFNetworking\", \"~> 2.0\"\n\t```\n\t随后退出编辑模式，执行：\n\t```\n\tpod install\n\t```\n\t不过你在执行此条命令时会要等N久，主要是执行上述命令时会升级Cocoapods的spec仓库，加一个参数就可以省略这一步，然后速度就会有相当大的提升，命令如下：\n\t```\n\tpod install --verbose --no-repo-update\n\tpod update --verbose --no-repo-update\n\t```\n\t\n\t","source":"_posts/CocoaPods-下载和安装.md","raw":"title: \"CocoaPods 下载和安装\"\ndate: 2014-05-25 15:02:45\ntags: CocoaPods\n---\n\n###下载和安装\n\n\t在安装之前，首先要在本地安装好Ruby环境。如果你在本地已经安装好Ruby环境，那么下载和安装CocoaPods将十分简单，只需要一行命令。在终端中输入如下命令\n\t```\n\tsudo gem install cocoapods\n\t```\n\t但是，如果你在天朝，在终端中敲入这个命令之后，会发现半天没有任何反应。原因无他，因为那堵墙阻挡了cocoapods.org。我们可以用淘宝的Ruby镜像来访问cocoapods。按照下面的顺序在终端中依次敲入命令：\n\t```\n\tgem source --remove https://rubygems.org/\n\tgem source -a http://ruby.taobao.org/\n\t```\n\t为了验证你的Ruby镜像是并且仅是taobao，可以用一下命令查看：\n\t```\n\tgem source -l\n\t```\n\t只有在终端中出现下面文字才表明你上面的命令是成功的：\n\t```\n\t*** CURRENT SOURCES ***\n\thttp://ruby.taobao.org/\n\t```\n\t此时，你再次在终端中运行：\n\t```\n\tsudo gem install cocoapods\n\t```\n\t\n###使用CocoaPods\n\n\t安装好之后就是如何使用它了。我们以AFNetworking来说明吧\n\tAFNetworking类库在Github地址是:(https://github.com/AFNetworking/AFNetworking)\n\t为了确定AFnetworking是否支持Cocoapods，可以用Cocoapods的搜索功能验证一下。在终端中输入：\n\t```\n\tpod search AFnetworking\n\t```\n\t随后你会看到相关信息，准备工作也差不多了，下面让我们进入正题\n\t首先先利用Xcode创建一个项目工程。随后在终端中进入所创建的项目文件中，然后运行：\n\t```\n\tpod init\n\t```\n\t随后cocoapods会为项目自动生成一个Podfile文件，执行：\n\t```\n\tvim Podfile\n\t```\n\t然后再Podfile文件中target和end之间输入以下信息：\n\t```\n\tplatform :ios, '7.0'\n\tpod \"AFNetworking\", \"~> 2.0\"\n\t```\n\t随后退出编辑模式，执行：\n\t```\n\tpod install\n\t```\n\t不过你在执行此条命令时会要等N久，主要是执行上述命令时会升级Cocoapods的spec仓库，加一个参数就可以省略这一步，然后速度就会有相当大的提升，命令如下：\n\t```\n\tpod install --verbose --no-repo-update\n\tpod update --verbose --no-repo-update\n\t```\n\t\n\t","slug":"CocoaPods-下载和安装","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid1z800003rtcl8nh106i"},{"title":"面向对象思想——个人理解","date":"2014-05-06T09:28:23.000Z","_content":"\n1. 基本概念\n\n\t1.1 类与对象的初探\n\t\n\t\t “这个世界时由什么组成的？”这个问题如果让不同的人来回答会得到不同的答案。如果是一个化学家，他也许会告诉你“还用问么，这个世界是由分子、原子、离子等等化学物质组成的”。如果是一个画家呢？他也许会告诉你，“这个世界是由不同的颜色所组成的”......呵呵，众说纷纭吧！但如果让一个分类学家来考虑问题就有趣的多了，他会告诉你“这个世界是由不同类型的物与事所构成的”好！作为面向对象的程序员来说，我们要站在分类学家的角度去考虑问题！是的，这个世界是由动物、植物等组成的。动物又分为单细胞动物、多细胞动物、哺乳动物等等，哺乳动物又分为人、大象、老虎......就这样的分下去了！\n\t\n\t\t现在，站在抽象的角度，我们给“类”下个定义吧！我的意思是，站在抽象的角度，你回答我“什么是人类？”首先让我们来看看人类所具有的一些特征，这个特征包括属性（一些参数，数值）以及方法（一些行为，他能干什么！）。每个人都身高、体重、年龄、血型等等一些属性。人会劳动、人都会直立行走、人都会用自己的头脑去创造工具等等这些方法。“人类”只是一个抽象的概念，它仅仅是一个概念，它使不存在的实体！但是所有具备“人类”这个群体的属性与方法的对象都叫人！这个对象“人”是实际存在的实体！每个人都是这个群体的一个对象。老虎为什么不是人？因为它不具备人类这个群体的属性与方法，老虎不会直立行走，不会使用工具等等！所以说老虎不是人！\n\t\t\n\t\t由此可见————类描述了一组有相同特性（属性）和相同行为（方法）的对象。在程序中，类实际上就是数据类型！例如：整数，小树等等。整数也有一组特性和行为。面型过程的语言与面向对象的语言的区别就在于，面相过程的语言不允许程序员自己定义数据类型，而只能使用程序中内置的数据类型！而为了模拟真实世界，为了更好地解决问题，往往我们需要创建解决问题所必需的数据类型！面向对象编程为我们提供了解决方案。\n\t\n\t1.2 内置数据类型与函数\n\t\t\n\t\t计算机程序在存储数据时必须跟踪3个基本属性为：\n\t\t1. 信息存储在何处；\n\t\t2. 存储的值是多少；\n\t\t3. 存储的信息是什么类型的；\n\t\t\n\t\t让我们来看看编程语言的内置数据类型都有哪些！（这个不大好说，因为每门语言都有自己独特的数据类型，但这毕竟是少数，比如在JAVA中有byte类型的数据，而在C++中就没有）比如整数“int”，浮点类型的数据“float”！字符串“string”，以及数组还有结构体等等。然而在写程序的时候，根据需要我们会创建一个类型的变量或常量。例如：忧郁我们需要创建一个整形的变量i为5，我们就可以这样做，int i = 5；而根据需要我很有可能改变i的值，也就是从新给它赋值，比如让它等于6，就可以在所需的地方改为i = 6；由此我们知道，在“值”上可以发生变化的量就叫变量。不会发生变化的量就叫做常量了，在C++中用count关键字来声明，而在JAVA中则使用final关键字来声明。由于不同语言的声明格式不一样，这里就不做一一介绍，详细的内容清查阅相关书籍！\n\t\t\n\t\t在这里我们主要讨论一下函数，我们可以把函数想象成一个“实现某种特定功能的黑匣子”————这个功能是由你来设定的，举个例子说：现在我问你“2+3等于多少？”我相信你能很快的回答我等于5。让我们来分析分析这句话包含什么信息！首先我要把你的大脑想象成是一个黑匣子，我并不知道也没有必要知道你的大脑是如何工作的（也就是怎么运算的），我关心的只是我传给你的事什么信息？你对信息做了哪些处理？以及你返回给我的什么信息？需要提醒你一下的是每个方法都会返回一个信息给调用者的，除了构造函数外。我现在需要把自己当做是一名程序员，而你呢？当然就是计算机了！计算机可没有人那么聪明，它只会按事先约好的特定的格式运行，我想让它具有如上所述的功能，我就要先定义这个黑匣子！首先我要告诉这个黑匣子会有两个整数值给你（这就是所谓的参数，是程序员需要给黑匣子的信息），然后就要定义这个黑匣子内部实现这两个整数相加的运算（这就是黑匣子对数据所做的加工，根据需要，你可以任何的加工）。最后再标注它返回给我一个同样是整型的数值（这时黑匣子返回给程序员的信息）。一个函数就这样定义完了，让我们来看看书写格式：\n\t\t\n\t\t```\n\t\tint addnum(int x, int y) {\n\t\t\treturn x + y;\n\t\t}\n\t\t```\n\n\t具体的含义是这样的：\n\t\t\n\t\tint(返回值类型) \n\t\taddnum (方法名称)\n\t\t(int x, int y)(传入的参数)\n\t\treturn x+y;(内部实现方法，实现相加运算，并return返回给调用者结果)\n\t\t\n\t\t就像上面一样，因为我问你，你才会回答我，如果我不问你，你就不用回答我！在计算机中也一样，定义好这个函数在哪里调用呢？我只能告诉你，哪里需要就在哪里调用！\n\t\t\n\t\t关于函数的话题还有很多很多，这里就不一一介绍了，我的目的就是先说说函数是怎么一回事儿！为下面的讨论作铺垫！\n\t\t\n\t1.3 指针以及引用\n\t\n\t\t指针及引用是在C++中有的，JAVA中没有。JAVA中取消了对内存的操作，随之而来的事也取消了操作符重载的操作。不过在稍后还是会介绍一些操作符重载的功能等。引用主要还是用在函数参数的传递上。所以在这里就不做过多的介绍了。\n\t\n2. 深入探讨面相对对象\n\n\t2.1 “类型”的内部的细节\n\t\n\t\t面相对象的变成语言最大的特色就是可以编写自己所需的数据类型，以更好的解决问题。就像前面所说的，人这个“类”是什么也做不了的，因为“人类”只是一个抽象的概念，它不是实实在在的“东西”，而这个“东西”就是所谓的对象。只有人这个“对象”才能去工作。而类呢？类是对象的描述！对象从类中产生出来！此时，对象具有类所描述的所有的属性以及方法。再来举个例子！例如电视机，电视机都有工作原理图，那么什么电视机呢？只要它能够实现工作原理图的所有功能的物体，我们都叫它电视机。你想想是不是这么一回事儿？可是，电视机原理图是不能工作的，也就是这个原理图不能收看节目，只有电视机这个“实体”----即所谓的“对象”才能收看节目，也就是说，从类生成出对象之后才算得上是真正的有意义！才能开始工作。此时，电视机拥有电视原理图所描述的所有的属性及方法！明白了吧，呵呵！\n\t\t\n\t\t类是属性与方法的集合。而这些属性与方法可以被声明为私有的（private），公共的（public）或是受保护（protected）的，他们描述了对类成员的访问控制。下面介绍一下：\n\t\t1. 公共的（public）：把变量声明为公共类型的之后，那么就可以通过对象来直接访问，一切都是暴露无遗的！也就是说，你的信用卡密码别人也能够直接得到。\n\t\t2. 私有的（private）：如果把变量声明为私有的情况就好多了，想要得到我的信用卡面，对象必须要调用专用的方法才能够得到。\n\t\t3. 受保护的（protected）：介绍继承时在讨论。\n\t\t4. 默认控制访问符（friendly）：Java中又而C++中没有。\n\t\t为了实现数据的封装，提高数据的安全性，我们一般会把类的属性声明为私有的，而把类的方法声明为公共的。这样，对象能够直接调用类中定义的所有方法，当对象想要修改或得到自己的属性的时候就必须要调用以定义好的专用的方法才能够实现。你想想，你会把你的信用卡密码公布出来吗？所以，我们提倡的事：“对象调方法，方法改属性”；\n\t\t","source":"_posts/面相对象思想——个人理解.md","raw":"title: \"面向对象思想——个人理解\"\ndate: 2014-05-06 17:28:23\ntags: 面向对象思想\n---\n\n1. 基本概念\n\n\t1.1 类与对象的初探\n\t\n\t\t “这个世界时由什么组成的？”这个问题如果让不同的人来回答会得到不同的答案。如果是一个化学家，他也许会告诉你“还用问么，这个世界是由分子、原子、离子等等化学物质组成的”。如果是一个画家呢？他也许会告诉你，“这个世界是由不同的颜色所组成的”......呵呵，众说纷纭吧！但如果让一个分类学家来考虑问题就有趣的多了，他会告诉你“这个世界是由不同类型的物与事所构成的”好！作为面向对象的程序员来说，我们要站在分类学家的角度去考虑问题！是的，这个世界是由动物、植物等组成的。动物又分为单细胞动物、多细胞动物、哺乳动物等等，哺乳动物又分为人、大象、老虎......就这样的分下去了！\n\t\n\t\t现在，站在抽象的角度，我们给“类”下个定义吧！我的意思是，站在抽象的角度，你回答我“什么是人类？”首先让我们来看看人类所具有的一些特征，这个特征包括属性（一些参数，数值）以及方法（一些行为，他能干什么！）。每个人都身高、体重、年龄、血型等等一些属性。人会劳动、人都会直立行走、人都会用自己的头脑去创造工具等等这些方法。“人类”只是一个抽象的概念，它仅仅是一个概念，它使不存在的实体！但是所有具备“人类”这个群体的属性与方法的对象都叫人！这个对象“人”是实际存在的实体！每个人都是这个群体的一个对象。老虎为什么不是人？因为它不具备人类这个群体的属性与方法，老虎不会直立行走，不会使用工具等等！所以说老虎不是人！\n\t\t\n\t\t由此可见————类描述了一组有相同特性（属性）和相同行为（方法）的对象。在程序中，类实际上就是数据类型！例如：整数，小树等等。整数也有一组特性和行为。面型过程的语言与面向对象的语言的区别就在于，面相过程的语言不允许程序员自己定义数据类型，而只能使用程序中内置的数据类型！而为了模拟真实世界，为了更好地解决问题，往往我们需要创建解决问题所必需的数据类型！面向对象编程为我们提供了解决方案。\n\t\n\t1.2 内置数据类型与函数\n\t\t\n\t\t计算机程序在存储数据时必须跟踪3个基本属性为：\n\t\t1. 信息存储在何处；\n\t\t2. 存储的值是多少；\n\t\t3. 存储的信息是什么类型的；\n\t\t\n\t\t让我们来看看编程语言的内置数据类型都有哪些！（这个不大好说，因为每门语言都有自己独特的数据类型，但这毕竟是少数，比如在JAVA中有byte类型的数据，而在C++中就没有）比如整数“int”，浮点类型的数据“float”！字符串“string”，以及数组还有结构体等等。然而在写程序的时候，根据需要我们会创建一个类型的变量或常量。例如：忧郁我们需要创建一个整形的变量i为5，我们就可以这样做，int i = 5；而根据需要我很有可能改变i的值，也就是从新给它赋值，比如让它等于6，就可以在所需的地方改为i = 6；由此我们知道，在“值”上可以发生变化的量就叫变量。不会发生变化的量就叫做常量了，在C++中用count关键字来声明，而在JAVA中则使用final关键字来声明。由于不同语言的声明格式不一样，这里就不做一一介绍，详细的内容清查阅相关书籍！\n\t\t\n\t\t在这里我们主要讨论一下函数，我们可以把函数想象成一个“实现某种特定功能的黑匣子”————这个功能是由你来设定的，举个例子说：现在我问你“2+3等于多少？”我相信你能很快的回答我等于5。让我们来分析分析这句话包含什么信息！首先我要把你的大脑想象成是一个黑匣子，我并不知道也没有必要知道你的大脑是如何工作的（也就是怎么运算的），我关心的只是我传给你的事什么信息？你对信息做了哪些处理？以及你返回给我的什么信息？需要提醒你一下的是每个方法都会返回一个信息给调用者的，除了构造函数外。我现在需要把自己当做是一名程序员，而你呢？当然就是计算机了！计算机可没有人那么聪明，它只会按事先约好的特定的格式运行，我想让它具有如上所述的功能，我就要先定义这个黑匣子！首先我要告诉这个黑匣子会有两个整数值给你（这就是所谓的参数，是程序员需要给黑匣子的信息），然后就要定义这个黑匣子内部实现这两个整数相加的运算（这就是黑匣子对数据所做的加工，根据需要，你可以任何的加工）。最后再标注它返回给我一个同样是整型的数值（这时黑匣子返回给程序员的信息）。一个函数就这样定义完了，让我们来看看书写格式：\n\t\t\n\t\t```\n\t\tint addnum(int x, int y) {\n\t\t\treturn x + y;\n\t\t}\n\t\t```\n\n\t具体的含义是这样的：\n\t\t\n\t\tint(返回值类型) \n\t\taddnum (方法名称)\n\t\t(int x, int y)(传入的参数)\n\t\treturn x+y;(内部实现方法，实现相加运算，并return返回给调用者结果)\n\t\t\n\t\t就像上面一样，因为我问你，你才会回答我，如果我不问你，你就不用回答我！在计算机中也一样，定义好这个函数在哪里调用呢？我只能告诉你，哪里需要就在哪里调用！\n\t\t\n\t\t关于函数的话题还有很多很多，这里就不一一介绍了，我的目的就是先说说函数是怎么一回事儿！为下面的讨论作铺垫！\n\t\t\n\t1.3 指针以及引用\n\t\n\t\t指针及引用是在C++中有的，JAVA中没有。JAVA中取消了对内存的操作，随之而来的事也取消了操作符重载的操作。不过在稍后还是会介绍一些操作符重载的功能等。引用主要还是用在函数参数的传递上。所以在这里就不做过多的介绍了。\n\t\n2. 深入探讨面相对对象\n\n\t2.1 “类型”的内部的细节\n\t\n\t\t面相对象的变成语言最大的特色就是可以编写自己所需的数据类型，以更好的解决问题。就像前面所说的，人这个“类”是什么也做不了的，因为“人类”只是一个抽象的概念，它不是实实在在的“东西”，而这个“东西”就是所谓的对象。只有人这个“对象”才能去工作。而类呢？类是对象的描述！对象从类中产生出来！此时，对象具有类所描述的所有的属性以及方法。再来举个例子！例如电视机，电视机都有工作原理图，那么什么电视机呢？只要它能够实现工作原理图的所有功能的物体，我们都叫它电视机。你想想是不是这么一回事儿？可是，电视机原理图是不能工作的，也就是这个原理图不能收看节目，只有电视机这个“实体”----即所谓的“对象”才能收看节目，也就是说，从类生成出对象之后才算得上是真正的有意义！才能开始工作。此时，电视机拥有电视原理图所描述的所有的属性及方法！明白了吧，呵呵！\n\t\t\n\t\t类是属性与方法的集合。而这些属性与方法可以被声明为私有的（private），公共的（public）或是受保护（protected）的，他们描述了对类成员的访问控制。下面介绍一下：\n\t\t1. 公共的（public）：把变量声明为公共类型的之后，那么就可以通过对象来直接访问，一切都是暴露无遗的！也就是说，你的信用卡密码别人也能够直接得到。\n\t\t2. 私有的（private）：如果把变量声明为私有的情况就好多了，想要得到我的信用卡面，对象必须要调用专用的方法才能够得到。\n\t\t3. 受保护的（protected）：介绍继承时在讨论。\n\t\t4. 默认控制访问符（friendly）：Java中又而C++中没有。\n\t\t为了实现数据的封装，提高数据的安全性，我们一般会把类的属性声明为私有的，而把类的方法声明为公共的。这样，对象能够直接调用类中定义的所有方法，当对象想要修改或得到自己的属性的时候就必须要调用以定义好的专用的方法才能够实现。你想想，你会把你的信用卡密码公布出来吗？所以，我们提倡的事：“对象调方法，方法改属性”；\n\t\t","slug":"面相对象思想——个人理解","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid1zk00033rtc5svd3q36"},{"title":"迎着缺陷奔跑","date":"2014-04-30T01:55:14.000Z","_content":"\n    他是一个严重晕车的弄明，一上车，就会吐得一塌糊涂。连骑自行车，他也会恶心难受。他很少出门，连十多里外的小镇也很少去。如果把这个社会比作一辆车，那么“交通”和“信息”就是这个社会的两个轮子，而他的人生因为远离了“交通”，就像缺了一个轮子，他跑步起来了。\n    \n\t同龄人纷纷外出打工，很快赚回了真金白银，造起了新房，娶了妻子，生了孩子，其乐融融。而他只能承包了一些天地，种水稻，种小麦，种西瓜，种花生……勉强维持生计。年轻的姑娘很现实，看他造不起新房，连乘车出趟远门都可能吐得要了他的命，没有人愿意嫁给他。\n\t\n\t后来农闲的时候，村里人经常看到他跑到车站，尝试着乘车，乘一小段就会要求司机停车，然后蹲在地上吐一会儿。吐完了，再登下一班车来，然后又是乘一段，下车吐一会儿，如此循环。\n\t\n\t为了治自己的病，他徒步走到县医院、省医院，但没有一点效果。他又买了许多医药书，自己琢磨。阅读大量医书后，他终于明白，晕车是由于人的前庭系统太敏感引起的，如果要减轻晕车，唯一的办法就是抑制前庭系统的兴奋水平。\n\t\n\t三十岁那年，他对年迈的父母说，自己准备去学车。大家都反对，这样一个一上车就会呕吐的人，怎么可能？但他坚持。\n\t\n\t家人帮他找了一位教练，事先告诉教练他得情况。教练答应了老人，但他“一上车就吐”的症状还是让教练接受不了。于是，他每天上车前基本不吃东西，只喝一些盐水，这样肠胃里就没有什么可吐的了。神奇的是，症状竟然慢慢在减轻。他觉得自己的坚持是对的，满满的，他可以连续驾驶半个小时，身体也没有什么症状了。\n\t\n\t他拿到驾照后，借了不少钱，买了一辆二手的就卡车，跑起了运输，赚下了人生第一桶金，他也造起了房子娶了妻子。后来妻子因为他经常跑长途很担心，他索性卖掉了货车，举债到城里买了一辆出租车。现在他每天又8小时在出租车上，从来不会晕车了。\n\t\n\t有一天，这位司机与我一起吃放，说起他的故事，他说自己是一个“神医”，自己医好了自己的病。我不明白，当年他怎么知道开车可以医好晕车症呢？\n\t\n\t他说，有一次看二战片，片中有个场景：一艘太平洋上的战舰上，士兵们因为风浪太大晕船，此时，战舰雷达上捕获到前面有敌舰，敌舰武器装备精良。舰长知道士兵们因为晕船几无战斗力了，大家的命运凶多吉少。警报发出后，士兵们全部进入战斗位，集中火力射向战舰，鏖战一个小时候，敌舰仓皇而逃。而让人惊奇的是，所有士兵都没有了晕船症状。\n\t\n\t如果当年他没有去“啃”那些难懂的医药书，如果他没有看到这部片子，如果他没有不肯低头的勇气，他现在又将身处那种情景？\n\t\n\t上苍想来不会垂青一个弱者。幸运的是，他没有听从命运的安排，面对缺陷，不是逃避，而是面对，并且迎着缺陷奔跑，把可能毁掉他人生的“缺陷”狠狠地打倒在地，终于逆势起飞了。","source":"_posts/迎着缺陷奔跑.md","raw":"title: \"迎着缺陷奔跑\"\ndate: 2014-04-30 09:55:14\ntags: 故事一则\n---\n\n    他是一个严重晕车的弄明，一上车，就会吐得一塌糊涂。连骑自行车，他也会恶心难受。他很少出门，连十多里外的小镇也很少去。如果把这个社会比作一辆车，那么“交通”和“信息”就是这个社会的两个轮子，而他的人生因为远离了“交通”，就像缺了一个轮子，他跑步起来了。\n    \n\t同龄人纷纷外出打工，很快赚回了真金白银，造起了新房，娶了妻子，生了孩子，其乐融融。而他只能承包了一些天地，种水稻，种小麦，种西瓜，种花生……勉强维持生计。年轻的姑娘很现实，看他造不起新房，连乘车出趟远门都可能吐得要了他的命，没有人愿意嫁给他。\n\t\n\t后来农闲的时候，村里人经常看到他跑到车站，尝试着乘车，乘一小段就会要求司机停车，然后蹲在地上吐一会儿。吐完了，再登下一班车来，然后又是乘一段，下车吐一会儿，如此循环。\n\t\n\t为了治自己的病，他徒步走到县医院、省医院，但没有一点效果。他又买了许多医药书，自己琢磨。阅读大量医书后，他终于明白，晕车是由于人的前庭系统太敏感引起的，如果要减轻晕车，唯一的办法就是抑制前庭系统的兴奋水平。\n\t\n\t三十岁那年，他对年迈的父母说，自己准备去学车。大家都反对，这样一个一上车就会呕吐的人，怎么可能？但他坚持。\n\t\n\t家人帮他找了一位教练，事先告诉教练他得情况。教练答应了老人，但他“一上车就吐”的症状还是让教练接受不了。于是，他每天上车前基本不吃东西，只喝一些盐水，这样肠胃里就没有什么可吐的了。神奇的是，症状竟然慢慢在减轻。他觉得自己的坚持是对的，满满的，他可以连续驾驶半个小时，身体也没有什么症状了。\n\t\n\t他拿到驾照后，借了不少钱，买了一辆二手的就卡车，跑起了运输，赚下了人生第一桶金，他也造起了房子娶了妻子。后来妻子因为他经常跑长途很担心，他索性卖掉了货车，举债到城里买了一辆出租车。现在他每天又8小时在出租车上，从来不会晕车了。\n\t\n\t有一天，这位司机与我一起吃放，说起他的故事，他说自己是一个“神医”，自己医好了自己的病。我不明白，当年他怎么知道开车可以医好晕车症呢？\n\t\n\t他说，有一次看二战片，片中有个场景：一艘太平洋上的战舰上，士兵们因为风浪太大晕船，此时，战舰雷达上捕获到前面有敌舰，敌舰武器装备精良。舰长知道士兵们因为晕船几无战斗力了，大家的命运凶多吉少。警报发出后，士兵们全部进入战斗位，集中火力射向战舰，鏖战一个小时候，敌舰仓皇而逃。而让人惊奇的是，所有士兵都没有了晕船症状。\n\t\n\t如果当年他没有去“啃”那些难懂的医药书，如果他没有看到这部片子，如果他没有不肯低头的勇气，他现在又将身处那种情景？\n\t\n\t上苍想来不会垂青一个弱者。幸运的是，他没有听从命运的安排，面对缺陷，不是逃避，而是面对，并且迎着缺陷奔跑，把可能毁掉他人生的“缺陷”狠狠地打倒在地，终于逆势起飞了。","slug":"迎着缺陷奔跑","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid1zm00063rtcr1g45qes"},{"title":"手写代码UIButton图片和文字位置的设置","date":"2014-08-12T05:39:25.000Z","_content":"\n1. 首先对button的初始化，以及图片和文字的设置\n\n\t```\n\t//添加放弃和留下按钮\n    UIButton *dropBtn = [UIButton buttonWithType:UIButtonTypeCustom];\n    dropBtn.frame = CGRectMake(1*WIDHT/5, getViewHeight(foodNameLabel)+50, 60, 60);\n    [dropBtn setImage:[UIImage imageNamed:@\"icon_No@2x.png\"] forState:UIControlStateNormal];\n\n    dropBtn.titleLabel.font = [UIFont systemFontOfSize:15];\n    [dropBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];\n    [dropBtn setTitle:@\"放弃\" forState:UIControlStateNormal];\n    dropBtn.imageEdgeInsets = UIEdgeInsetsMake(0, -15, 0, 0);\n    dropBtn.titleEdgeInsets = UIEdgeInsetsMake( 0, -5, 0, 0);\n    [dropBtn addTarget:self action:@selector(dropAction:) forControlEvents:UIControlEventTouchUpInside];\n    \n    [self.view addSubview:dropBtn];\n    \n    UIButton *keepBtn = [UIButton buttonWithType:UIButtonTypeCustom];\n    keepBtn.frame = CGRectMake(WIDHT - 1*WIDHT/5 - 60, getViewHeight(foodNameLabel)+50, 60, 60);\n    [keepBtn setImage:[UIImage imageNamed:@\"icon_OK@2x.png\"] forState:UIControlStateNormal];\n    \n    keepBtn.titleLabel.font = [UIFont systemFontOfSize:15];\n    [keepBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];\n    [keepBtn setTitle:@\"留下\" forState:UIControlStateNormal];\n    keepBtn.imageEdgeInsets = UIEdgeInsetsMake(0, 35, 0, -15);\n    keepBtn.titleEdgeInsets = UIEdgeInsetsMake( 0, -65, 0, 0);\n    [keepBtn addTarget:self action:@selector(keepAction:) forControlEvents:UIControlEventTouchUpInside];\n    \n    [self.view addSubview:keepBtn];\n\n\t```\n\t\n2. 以上就是所有代码，其中下列代码是对图片和文字位置的设置，UIEdgeInsets属性就上左下右的顺序设置，`‘-’加到数字前就是指负向偏移，‘+’是正向偏移`，其实imageEdgeInsets中的第一个数值是对图片对于button上边距的距离，第二个数值是对图片对于button左边距的距离，第三个数值是对图片对于button下边距的距离，第四个数值是对图片对于button的右边距的距离，而titleEdgeInsets的设置类似的。\n\t```\n\tkeepBtn.imageEdgeInsets = UIEdgeInsetsMake(0, 35, 0, -15);\n\tkeepBtn.titleEdgeInsets = UIEdgeInsetsMake( 0, -65, 0, 0);\n\t```\n\t我所实现的效果图如下：\n\t![image](/images/手写UIButton/20150812.png)\n\t具体需要实现什么效果还是需要你自己把握的","source":"_posts/手写代码UIButton图片和文字位置的设置.md","raw":"title: \"手写代码UIButton图片和文字位置的设置\"\ndate: 2014-08-12 13:39:25\ntags: 手写Button设置\n---\n\n1. 首先对button的初始化，以及图片和文字的设置\n\n\t```\n\t//添加放弃和留下按钮\n    UIButton *dropBtn = [UIButton buttonWithType:UIButtonTypeCustom];\n    dropBtn.frame = CGRectMake(1*WIDHT/5, getViewHeight(foodNameLabel)+50, 60, 60);\n    [dropBtn setImage:[UIImage imageNamed:@\"icon_No@2x.png\"] forState:UIControlStateNormal];\n\n    dropBtn.titleLabel.font = [UIFont systemFontOfSize:15];\n    [dropBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];\n    [dropBtn setTitle:@\"放弃\" forState:UIControlStateNormal];\n    dropBtn.imageEdgeInsets = UIEdgeInsetsMake(0, -15, 0, 0);\n    dropBtn.titleEdgeInsets = UIEdgeInsetsMake( 0, -5, 0, 0);\n    [dropBtn addTarget:self action:@selector(dropAction:) forControlEvents:UIControlEventTouchUpInside];\n    \n    [self.view addSubview:dropBtn];\n    \n    UIButton *keepBtn = [UIButton buttonWithType:UIButtonTypeCustom];\n    keepBtn.frame = CGRectMake(WIDHT - 1*WIDHT/5 - 60, getViewHeight(foodNameLabel)+50, 60, 60);\n    [keepBtn setImage:[UIImage imageNamed:@\"icon_OK@2x.png\"] forState:UIControlStateNormal];\n    \n    keepBtn.titleLabel.font = [UIFont systemFontOfSize:15];\n    [keepBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];\n    [keepBtn setTitle:@\"留下\" forState:UIControlStateNormal];\n    keepBtn.imageEdgeInsets = UIEdgeInsetsMake(0, 35, 0, -15);\n    keepBtn.titleEdgeInsets = UIEdgeInsetsMake( 0, -65, 0, 0);\n    [keepBtn addTarget:self action:@selector(keepAction:) forControlEvents:UIControlEventTouchUpInside];\n    \n    [self.view addSubview:keepBtn];\n\n\t```\n\t\n2. 以上就是所有代码，其中下列代码是对图片和文字位置的设置，UIEdgeInsets属性就上左下右的顺序设置，`‘-’加到数字前就是指负向偏移，‘+’是正向偏移`，其实imageEdgeInsets中的第一个数值是对图片对于button上边距的距离，第二个数值是对图片对于button左边距的距离，第三个数值是对图片对于button下边距的距离，第四个数值是对图片对于button的右边距的距离，而titleEdgeInsets的设置类似的。\n\t```\n\tkeepBtn.imageEdgeInsets = UIEdgeInsetsMake(0, 35, 0, -15);\n\tkeepBtn.titleEdgeInsets = UIEdgeInsetsMake( 0, -65, 0, 0);\n\t```\n\t我所实现的效果图如下：\n\t![image](/images/手写UIButton/20150812.png)\n\t具体需要实现什么效果还是需要你自己把握的","slug":"手写代码UIButton图片和文字位置的设置","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid1zp00093rtc8ix0gza4"},{"title":"iOS开发——MD5加密算法","date":"2014-08-03T05:35:22.000Z","_content":"\n1. MD5加密算法，实现类别如下：\n\n\t方法一：\n\t```\n\t#import <CommonCrypto/CommonDigest.h>\n\t\n\t@interface NSString (md5)\n\t-(NSString *)md5HexDigest;\n\t@end\n\t\n\t#improt \"NSString+MD5HexDigest.h\"\n\t\n\t@implementation NSString (md5)\n\t\n\t- (NSString *)md5HexDigest {\n\t\tconst char *original_str = [self UTF8String];\n\t\tunsigned char result[CC_MD5_DIGEST_LENGTH];\n\t\tCC_MD5(original_str, strlen(original_str), result);\n\t\tNSMutableString *hash = [NSMutableString string];\n\t\tfor (int i = 0;i < 16; i++) {\n\t\t\t[hash appendFormat:@\"%02X\", result[i]];\n\t\t}\n\t\treturn [hash lowercaseString];\n\t}\n\t\n\t@end\n\t```\n\n\t方法二：\n\t将字符串进行MD5加密，返回加密后的字符串\n\t```\n\t#import <CommonCrypro/CommonDigest.h>\n\t\n\t- (NSString *)md5WithString:(NSString *)str\n\t{\n\t\tconst char *cStr = [str UTF8String];\n\t\tunsigned char result[16];\n\t\tCC_MD5(cStr, strlen(cStr), result);// this is the md call\n\t\treturn [NSString stringWithFormat:@\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\",  \n\t\tresult[0], result[1], result[2], result[3], \n        result[4], result[5], result[6], result[7],\n        result[8], result[9], result[10], result[11],\n        result[12], result[13], result[14], result[15]];\n\t}\n\t```\n\t`注意：` MD5是不可逆的只有加密没有解密","source":"_posts/iOS开发——MD5加密算法.md","raw":"title: \"iOS开发——MD5加密算法\"\ndate: 2014-08-03 13:35:22\ntags: MD5加密\n---\n\n1. MD5加密算法，实现类别如下：\n\n\t方法一：\n\t```\n\t#import <CommonCrypto/CommonDigest.h>\n\t\n\t@interface NSString (md5)\n\t-(NSString *)md5HexDigest;\n\t@end\n\t\n\t#improt \"NSString+MD5HexDigest.h\"\n\t\n\t@implementation NSString (md5)\n\t\n\t- (NSString *)md5HexDigest {\n\t\tconst char *original_str = [self UTF8String];\n\t\tunsigned char result[CC_MD5_DIGEST_LENGTH];\n\t\tCC_MD5(original_str, strlen(original_str), result);\n\t\tNSMutableString *hash = [NSMutableString string];\n\t\tfor (int i = 0;i < 16; i++) {\n\t\t\t[hash appendFormat:@\"%02X\", result[i]];\n\t\t}\n\t\treturn [hash lowercaseString];\n\t}\n\t\n\t@end\n\t```\n\n\t方法二：\n\t将字符串进行MD5加密，返回加密后的字符串\n\t```\n\t#import <CommonCrypro/CommonDigest.h>\n\t\n\t- (NSString *)md5WithString:(NSString *)str\n\t{\n\t\tconst char *cStr = [str UTF8String];\n\t\tunsigned char result[16];\n\t\tCC_MD5(cStr, strlen(cStr), result);// this is the md call\n\t\treturn [NSString stringWithFormat:@\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\",  \n\t\tresult[0], result[1], result[2], result[3], \n        result[4], result[5], result[6], result[7],\n        result[8], result[9], result[10], result[11],\n        result[12], result[13], result[14], result[15]];\n\t}\n\t```\n\t`注意：` MD5是不可逆的只有加密没有解密","slug":"iOS开发——MD5加密算法","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid1zr000c3rtcmg4z937v"},{"title":"iOS学习-Quartz2D使用","date":"2014-03-31T13:29:47.000Z","_content":"###一、什么是Quartz2D?\n1. Quartz2D是一个二维绘图引擎，同时支持IOS和Mac系统,基于路径的绘制\n2. Quartz2D能做成的工作\n3. 绘制图形：线条、三角形，矩形，圆，弧等\n4. 绘制文字\n5. 绘制/生成图片（图像）\n6. 读取/生成PDF\n7. 截图/裁剪图片\n8. 自定义UI控件。（当我们不满足系统给出的控件，可以自己制造）\n9. `Quartz2D的API是纯C语言的，Quartz2D的API基于core Graphics框架`\n \n###二、Quartz2D是怎样将绘图信息和绘图的属性绘制到图形上下文中去的呢？\n`说明：` \t\n- 新建一个项目，自定义一个view类和storyboard关联后，重写该类中的drawRect：方法,drawRect方法当View第一次显示到屏幕上时会被调用，以及调用setNeedsDisplay或者setNeedsDisplayInRectangular时   \n+ 划线的三个步骤：\n \n 1.  获取上下文\n 2.\t绘制路径\n 3.\t渲染\n\n####Paths\n\n1. paths中的重要元素\n*Point（点）*\n\n```\n\tvoid CGContextMoveToPoint (\n\t    CGContextRef c,\n\t    CGFloat x,\n\t    CGFloat y\n\t );\n\t 指定一个点成为当前点（current point），Quartz会更重current point，执行完一个相关函数后，current point会相应的改变到函数结束位置 \n```\n*Lines（线段）*\n\n相关的几个函数\n```\n\t void CGContextAddLineToPoint (\n\t    CGContextRef c,\n\t    CGFloat x,\n\t    CGFloat y\n\t );\n\t 创建一条直线，从current point到 (x,y)\n\t 然后current point会变成(x,y)\n\t \n\t void CGContextAddLines (\n\t    CGContextRef c,\n\t    const CGPoint points[],\n\t    size_t count\n\t );\n\t 创建多条直线，比如points有两个点，那么会画两条直线 从current point到 (x1,y1),\n\t 然后是(x1,y1)到(x2,y2)\n\t 然后current point会变成points中的最后一个点\n\t \n\t //设置线段的宽度\n\t CGContextSetLineWidth(CGContextRef c, CGFloat width)\n\t\n\t//设置线段头尾部的样式(但是Xcode更新后好多效果都差不多)\n\tCGContextSetLineCap(CGContextRef c, CGLineCap cap)//第二个参数是枚举值\n\t\n\t//设置线段转折点的样式\n\tCGContextSetLineJoin(CGContextRef c, CGLineJoin join)//同上\n\t\n\t//设置点划线的样式\n    const CGFloat lengths[]={2,6,4,1};\n    CGContextSetLineDash(ctx, 0, lengths, 4);\n\tCGContextSetLineDash(CGContextRef c, CGFloat phase, const CGFloat *lengths, size_t count)\n```\n*Arcs（弧线）*\n\n1. 创建弧线之弧度法\n\t 假如想创建一个完整的圆圈，那么 开始弧度就是0 结束弧度是 2pi， 因为圆周长是 2*pi*r.\n\t 最后，函数执行完后，current point就被重置为(x,y).\n\t 还有一点要注意的是，假如当前path已经存在一个subpath，那么这个函数执行的另外一个效果是有一条直线，从current point到弧的起点\n\t ```\n\t void CGContextAddArc (\n\t    CGContextRef c,    \n\t    CGFloat x,             //圆心的x坐标\n\t    CGFloat y,    //圆心的y坐标\n\t    CGFloat radius,   //圆的半径 \n\t    CGFloat startAngle,    //开始弧度\n\t    CGFloat endAngle,   //结束弧度（360°是2* M_PI不是M_2_PI）\n\t    int clockwise          //0表示顺时针，1表示逆时针\n\t );\n\t ```\n2. 创建弧线之切线法\n\t原理：首先画两条线，这两条线分别是 current point to (x1,y1) 和(x1,y1) to (x2,y2).\n\t 这样就是出现一个以(x1,y1)为顶点的两条射线，\n\t 然后定义半径长度，这个半径是垂直于两条射线的，这样就能决定一个圆了，更好的理解看下图，不过个人认为下图所标的 tangent point 1的位置是错误的。\n\t 最后，函数执行完后，current point就被重置为(x2,y2).\n\t \n\t ```\n\t void CGContextAddArcToPoint (\n\t    CGContextRef c,\n\t    CGFloat x1,  //端点1的x坐标\n\t    CGFloat y1,  //端点1的y坐标\n\t    CGFloat x2,  //端点2的x坐标\n\t    CGFloat y2,  //端点2的y坐标\n\t    CGFloat radius //半径\n\t );\n\t ```\n\t \t \n*Curves(曲线)*\n定义几个控制点，切着控制点组成的直线而形成的曲线\n\t1. 三次曲线函数\n\t```\n\tvoid CGContextAddCurveToPoint (\n\t\t    CGContextRef c,\n\t\t    CGFloat cp1x, //控制点1 x坐标\n\t\t    CGFloat cp1y, //控制点1 y坐标\n\t\t    CGFloat cp2x, //控制点2 x坐标\n\t\t    CGFloat cp2y, //控制点2 y坐标\n\t\t    CGFloat x,  //曲线的终点 x坐标\n\t\t    CGFloat y  //曲线的终点 y坐标\n\t\t );\n\t```\n\t2. 二次曲线函数\n\t```\n\tvoid CGContextAddQuadCurveToPoint (\n\t    CGContextRef c,\n\t    CGFloat cpx,  //控制点 x坐标\n\t    CGFloat cpy,  //控制点 y坐标\n\t    CGFloat x,  //曲线的终点 x坐标\n\t    CGFloat y  //曲线的终点 y坐标\n\t  );\n\t```\n\t\n*Clip（剪辑）*\n`裁剪原理`\n\t自定义一个View，在这个View中勾画出你要裁剪的区域，然后再将图片盖到裁剪区域的上方，指定裁剪的地方显示出来，其他地方不显示，这就是裁剪的原理。\n\n---\n\n####例子：\n- 要求：绘制颜色为红色的直线，利用的颜色空间设置颜色\n- `注意：`颜色空间设置颜色必须在绘制完成之后对其进行回收\n- 代码：\n\n```\n- (void)drawRect:(CGRect)rect\n{\n    // Drawing code\n    // 1. 获取绘图上下文\n    CGContextRef ctx = UIGraphicsGetCurrentContext();\n    \n    // 2. 设置绘图状态\n    // 设置线宽\n    CGContextSetLineWidth(ctx, 1);\n    \n    // 设置颜色\n    // 创建颜色空间\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    const CGFloat components[] = {1,0,0,1};\n    // 创建颜色\n    CGColorRef color = CGColorCreate(colorSpace, components);\n    // 设置描边的颜色\n    CGContextSetStrokeColorWithColor(ctx, color);\n    \n    // 设置点划线\n//    const CGFloat lengths[] = {2,6,4,1};\n//    CGContextSetLineDash(ctx, 0, lengths, 4);\n    \n    // 3. 构建Path\n    NSLog(@\"%@\", NSStringFromCGPoint(rect.origin));\n    // 移动画笔到指定点\n    // 开始path\n    CGContextBeginPath(ctx);\n    CGContextMoveToPoint(ctx, rect.origin.x, rect.origin.y);\n    \n    // 添加一条直线\n    CGContextAddLineToPoint(ctx, CGRectGetMaxX(rect), CGRectGetMaxY(rect));\n    \n    // 关闭path\n    CGContextClosePath(ctx);\n    \n    // 4. 绘制 stroke fill\n//    CGContextFillPath(<#CGContextRef c#>)\n//    CGContextStrokePath(<#CGContextRef c#>)\n    CGContextDrawPath(ctx, kCGPathStroke);\n    \n    // 5. 回收资源\n    CGColorRelease(color);\n    CGColorSpaceRelease(colorSpace);\n}\n```\n\n- 效果图：\n![image](/images/Quartz2D/Line.png)\n\n- 要求：绘制矩形区域，以红线描边，绿色填充\n- 代码：\n\n```\n- (void)drawRect:(CGRect)rect\n{\n    // 获取上下文\n    CGContextRef ctx = UIGraphicsGetCurrentContext();\n    // 设置描边颜色\n    CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);\n    // 设置填充颜色\n    CGContextSetFillColorWithColor(ctx, [UIColor greenColor].CGColor);\n    // 设置线宽\n    CGContextSetLineWidth(ctx, 3);\n    // 添加矩形区域\n    CGContextAddRect(ctx, rect);\n    \n//    CGContextStrokePath(ctx);\n\t// 绘制区域以及线\n    CGContextDrawPath(ctx, kCGPathFillStroke);\n}\n```\n- 效果图：\n![image](/images/Quartz2D/Rect.png)\n\n- 要求：绘制弧线，以切线方法，最终绘制为一个直径为100的圆\n- 代码：\n\n```\n- (void)drawRect:(CGRect)rect\n{\n    // 获取上下文\n    CGContextRef ctx = UIGraphicsGetCurrentContext();\n    // 设置描边颜色\n    CGContextSetStrokeColorWithColor(ctx, [UIColor greenColor].CGColor);\n    \n    CGFloat x = rect.origin.x;\n    CGFloat y = 100;\n    // 移动画笔到第一个切点(以rect顶点为原点)\n    CGContextMoveToPoint(ctx, x, y);\n    // 确定两条切线交点位置，以及另一个切点位置\n    //CGContextAddArcToPoint(CGContextRef c, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius)\n    // c代表上下文，x1为交点x坐标，y1为交点y坐标，x2为第二切点的x，y2为第二切点的y，radius为弧线半径\n    CGContextAddArcToPoint(ctx, x, y+100, x+100, y+100, 100);\n    CGContextAddArcToPoint(ctx, x+200, y+100, x+200, y, 100);\n    CGContextAddArcToPoint(ctx, x+200, y-100, x+100, y-100, 100);\n    CGContextAddArcToPoint(ctx, x, y-100, x, y, 100);\n    // 绘制\n    CGContextStrokePath(ctx);\n}\n```\n- 效果图：\n![image](/images/Quartz2D/Arc.png)\n\n- 要求：绘制贝塞尔曲线\n- 代码：\n\n```\n- (void)drawRect:(CGRect)rect\n{\n\t// 获取上下文\n    CGContextRef ctx = UIGraphicsGetCurrentContext();\n    \n    CGContextSetStrokeColorWithColor(ctx, [UIColor blackColor].CGColor);\n    \n    CGFloat x = 0;\n    CGFloat y = 0;\n    \n    CGContextMoveToPoint(ctx, x, y);\n    \n    // CGContextAddCurveToPoint(CGContextRef c, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)\n    // cp1x，cp1y代表第一个贝塞尔参考点位置x和y，最后的xy代表终点位置\n    CGContextAddCurveToPoint(ctx, x+150, y+50, x+50, y+350, x+200, y+400);\n   //CGContextAddArcToPoint(ctx, x+150, y+50, x+200, y, 100);\n//    CGContextAddArcToPoint(ctx, x+200, y-100, x+100, y-100, 100);\n//    CGContextAddArcToPoint(ctx, x, y-100, x, y, 100);\n    \n    CGContextStrokePath(ctx);\n}\n```\n\n- 效果图：\n![image](/images/Quartz2D/curve.png)\n\n###三、UIBezierPath类\n1. 使用UIBezierPath类可以创建基于矢量的路径。此类是Core Graphics框架关于path的一个封装。使用此类可以定义简单的形状，如椭圆或者矩形，或者有多个直线和曲线段组成的形状。\n2. UIBezierPath对象是CGPathRef数据类型的封装。path如果是基于矢量形状的，都用直线和曲线段去创建。我们使用直线段去创建矩形和多边形，使用曲线段去创建弧（arc），圆或者其他复杂的曲线形状。每一段都包括一个或者多个点，绘图命令定义如何去诠释这些点。每一个直线段或者曲线段的结束的地方是下一个的开始的地方。每一个连接的直线或者曲线段的集合成为subpath。一个UIBezierPath对象定义一个完整的路径包括一个或者多个subpaths。\n3. 创建和使用一个path对象的过程是分开的。创建path是第一步，包含一下步骤：\n\t1. 创建一个path对象。\n\t2. 使用方法moveToPoint:去设置初始线段的起点。\n\t3. 添加line或者curve去定义一个或者多个subpaths。\n\t4. 改变UIBezierPath对象跟绘图相关的属性。例如，我们可以设置stroked path的属性lineWidth和lineJoinStyle。也可以设置filled path的属性usesEvenOddFillRule。\n- 要求：绘制圆角矩形，以及绘制不带箭尾的箭\n- 代码：\n\n```\n- (void)drawRect:(CGRect)rect\n{\n    // Drawing code\n    // 绘制圆角矩形\n    // 1. 创建bezier path\n    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(100, 50)];\n    // 2. 设置填充颜色\n    [[UIColor greenColor] setFill];\n    \n    // 3. 填充\n    [path fill];\n    /**\n     *  绘制不带箭尾的箭\n     *  UIBezierPath\n     */\n    \n    // 1. 黑色的箭shaft(轴)\n    UIBezierPath *p = [UIBezierPath bezierPath];\n    [p setLineWidth:20];\n    [p moveToPoint:CGPointMake(100, 100)];\n    [p addLineToPoint:CGPointMake(100, 25)];\n    [[UIColor blackColor] setStroke];\n    [p stroke];\n    \n    // 2. 红色的箭头(arrow)\n    [[UIColor redColor] setFill];\n    [p moveToPoint:CGPointMake(80, 25)];\n    [p addLineToPoint:CGPointMake(100, 0)];\n    [p addLineToPoint:CGPointMake(120, 25)];\n    [p fill];\n}\n```\n- 效果图：\n![image](/images/Quartz2D/bezierpath.png)\n\n- 要求：绘制渐变色箭尾的箭\n- 代码：\n```\n- (void)drawRect:(CGRect)rect\n{\n    // 坐标系转换(坐标原点转换到（80，0）位置)\n    CGContextTranslateCTM(ctx, 80, 0);\n    \n    // > 设置箭尾的三角区为不绘制区域(clipping)\n    // 保存初始状态\n    CGContextSaveGState(ctx);\n    \n    CGContextMoveToPoint(ctx, 10, 100);\n    CGContextAddLineToPoint(ctx, 20, 90);\n    CGContextAddLineToPoint(ctx, 30, 100);\n    // CGContextGetClipBoundingBox自动绘制一个包含上述三角形的矩形区域\n    CGRect flipRect = CGContextGetClipBoundingBox(ctx);\n    \n    CGContextAddRect(ctx, flipRect);\n    // 以奇偶填充法填充\n    CGContextEOClip(ctx);\n\n    // > 绘制箭杆\n    CGContextSetStrokeColorWithColor(ctx, [UIColor blackColor].CGColor);\n    CGContextSetLineWidth(ctx, 20);\n    \n    CGContextMoveToPoint(ctx, 20, 100);\n    CGContextAddLineToPoint(ctx, 20, 25);\n    // CGContextReplacePathWithStrokedPath将线转换为矩形区域\n    CGContextReplacePathWithStrokedPath(ctx);\n    \n    CGContextClip(ctx);\n    \n//    CGContextStrokePath(ctx);\n    \n    // 给shaft添加渐变\n    \n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    // 设置RGB以及Alpha\n    const CGFloat components[] = {0.6, 0.6, 0.6, 0.6,\n                                    0.0, 0.0, 0.0, 1.0,\n                                    0.6,0.6,0.6,0.6};\n    // 设置渐变位置\n    const CGFloat locations[] = {0, 0.618, 1};\n    \n    CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, components, locations, 3);\n    CGContextDrawLinearGradient(ctx, gradient, CGPointMake(10, 100), CGPointMake(30, 100), 0);\n    // 回到初始状态\n    CGContextRestoreGState(ctx);\n    // 回收颜色空间\n    CGColorSpaceRelease(colorSpace);\n    \n    // > 箭头\n    CGContextSetFillColorWithColor(ctx, [UIColor redColor].CGColor);\n    \n    CGContextMoveToPoint(ctx, 0, 25);\n    CGContextAddLineToPoint(ctx, 20, 0);\n    CGContextAddLineToPoint(ctx, 40, 25);\n    \n    CGContextFillPath(ctx);\n}\n```\n- 效果图：\n![image](/images/Quartz2D/arrowWithGradient.png)\n\n\n\n\t \n\n","source":"_posts/iOS学习-Quartz2D使用.md","raw":"title: \"iOS学习-Quartz2D使用\"\ndate: 2014-03-31 21:29:47\ntags: Quartz2D使用\n---\n###一、什么是Quartz2D?\n1. Quartz2D是一个二维绘图引擎，同时支持IOS和Mac系统,基于路径的绘制\n2. Quartz2D能做成的工作\n3. 绘制图形：线条、三角形，矩形，圆，弧等\n4. 绘制文字\n5. 绘制/生成图片（图像）\n6. 读取/生成PDF\n7. 截图/裁剪图片\n8. 自定义UI控件。（当我们不满足系统给出的控件，可以自己制造）\n9. `Quartz2D的API是纯C语言的，Quartz2D的API基于core Graphics框架`\n \n###二、Quartz2D是怎样将绘图信息和绘图的属性绘制到图形上下文中去的呢？\n`说明：` \t\n- 新建一个项目，自定义一个view类和storyboard关联后，重写该类中的drawRect：方法,drawRect方法当View第一次显示到屏幕上时会被调用，以及调用setNeedsDisplay或者setNeedsDisplayInRectangular时   \n+ 划线的三个步骤：\n \n 1.  获取上下文\n 2.\t绘制路径\n 3.\t渲染\n\n####Paths\n\n1. paths中的重要元素\n*Point（点）*\n\n```\n\tvoid CGContextMoveToPoint (\n\t    CGContextRef c,\n\t    CGFloat x,\n\t    CGFloat y\n\t );\n\t 指定一个点成为当前点（current point），Quartz会更重current point，执行完一个相关函数后，current point会相应的改变到函数结束位置 \n```\n*Lines（线段）*\n\n相关的几个函数\n```\n\t void CGContextAddLineToPoint (\n\t    CGContextRef c,\n\t    CGFloat x,\n\t    CGFloat y\n\t );\n\t 创建一条直线，从current point到 (x,y)\n\t 然后current point会变成(x,y)\n\t \n\t void CGContextAddLines (\n\t    CGContextRef c,\n\t    const CGPoint points[],\n\t    size_t count\n\t );\n\t 创建多条直线，比如points有两个点，那么会画两条直线 从current point到 (x1,y1),\n\t 然后是(x1,y1)到(x2,y2)\n\t 然后current point会变成points中的最后一个点\n\t \n\t //设置线段的宽度\n\t CGContextSetLineWidth(CGContextRef c, CGFloat width)\n\t\n\t//设置线段头尾部的样式(但是Xcode更新后好多效果都差不多)\n\tCGContextSetLineCap(CGContextRef c, CGLineCap cap)//第二个参数是枚举值\n\t\n\t//设置线段转折点的样式\n\tCGContextSetLineJoin(CGContextRef c, CGLineJoin join)//同上\n\t\n\t//设置点划线的样式\n    const CGFloat lengths[]={2,6,4,1};\n    CGContextSetLineDash(ctx, 0, lengths, 4);\n\tCGContextSetLineDash(CGContextRef c, CGFloat phase, const CGFloat *lengths, size_t count)\n```\n*Arcs（弧线）*\n\n1. 创建弧线之弧度法\n\t 假如想创建一个完整的圆圈，那么 开始弧度就是0 结束弧度是 2pi， 因为圆周长是 2*pi*r.\n\t 最后，函数执行完后，current point就被重置为(x,y).\n\t 还有一点要注意的是，假如当前path已经存在一个subpath，那么这个函数执行的另外一个效果是有一条直线，从current point到弧的起点\n\t ```\n\t void CGContextAddArc (\n\t    CGContextRef c,    \n\t    CGFloat x,             //圆心的x坐标\n\t    CGFloat y,    //圆心的y坐标\n\t    CGFloat radius,   //圆的半径 \n\t    CGFloat startAngle,    //开始弧度\n\t    CGFloat endAngle,   //结束弧度（360°是2* M_PI不是M_2_PI）\n\t    int clockwise          //0表示顺时针，1表示逆时针\n\t );\n\t ```\n2. 创建弧线之切线法\n\t原理：首先画两条线，这两条线分别是 current point to (x1,y1) 和(x1,y1) to (x2,y2).\n\t 这样就是出现一个以(x1,y1)为顶点的两条射线，\n\t 然后定义半径长度，这个半径是垂直于两条射线的，这样就能决定一个圆了，更好的理解看下图，不过个人认为下图所标的 tangent point 1的位置是错误的。\n\t 最后，函数执行完后，current point就被重置为(x2,y2).\n\t \n\t ```\n\t void CGContextAddArcToPoint (\n\t    CGContextRef c,\n\t    CGFloat x1,  //端点1的x坐标\n\t    CGFloat y1,  //端点1的y坐标\n\t    CGFloat x2,  //端点2的x坐标\n\t    CGFloat y2,  //端点2的y坐标\n\t    CGFloat radius //半径\n\t );\n\t ```\n\t \t \n*Curves(曲线)*\n定义几个控制点，切着控制点组成的直线而形成的曲线\n\t1. 三次曲线函数\n\t```\n\tvoid CGContextAddCurveToPoint (\n\t\t    CGContextRef c,\n\t\t    CGFloat cp1x, //控制点1 x坐标\n\t\t    CGFloat cp1y, //控制点1 y坐标\n\t\t    CGFloat cp2x, //控制点2 x坐标\n\t\t    CGFloat cp2y, //控制点2 y坐标\n\t\t    CGFloat x,  //曲线的终点 x坐标\n\t\t    CGFloat y  //曲线的终点 y坐标\n\t\t );\n\t```\n\t2. 二次曲线函数\n\t```\n\tvoid CGContextAddQuadCurveToPoint (\n\t    CGContextRef c,\n\t    CGFloat cpx,  //控制点 x坐标\n\t    CGFloat cpy,  //控制点 y坐标\n\t    CGFloat x,  //曲线的终点 x坐标\n\t    CGFloat y  //曲线的终点 y坐标\n\t  );\n\t```\n\t\n*Clip（剪辑）*\n`裁剪原理`\n\t自定义一个View，在这个View中勾画出你要裁剪的区域，然后再将图片盖到裁剪区域的上方，指定裁剪的地方显示出来，其他地方不显示，这就是裁剪的原理。\n\n---\n\n####例子：\n- 要求：绘制颜色为红色的直线，利用的颜色空间设置颜色\n- `注意：`颜色空间设置颜色必须在绘制完成之后对其进行回收\n- 代码：\n\n```\n- (void)drawRect:(CGRect)rect\n{\n    // Drawing code\n    // 1. 获取绘图上下文\n    CGContextRef ctx = UIGraphicsGetCurrentContext();\n    \n    // 2. 设置绘图状态\n    // 设置线宽\n    CGContextSetLineWidth(ctx, 1);\n    \n    // 设置颜色\n    // 创建颜色空间\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    const CGFloat components[] = {1,0,0,1};\n    // 创建颜色\n    CGColorRef color = CGColorCreate(colorSpace, components);\n    // 设置描边的颜色\n    CGContextSetStrokeColorWithColor(ctx, color);\n    \n    // 设置点划线\n//    const CGFloat lengths[] = {2,6,4,1};\n//    CGContextSetLineDash(ctx, 0, lengths, 4);\n    \n    // 3. 构建Path\n    NSLog(@\"%@\", NSStringFromCGPoint(rect.origin));\n    // 移动画笔到指定点\n    // 开始path\n    CGContextBeginPath(ctx);\n    CGContextMoveToPoint(ctx, rect.origin.x, rect.origin.y);\n    \n    // 添加一条直线\n    CGContextAddLineToPoint(ctx, CGRectGetMaxX(rect), CGRectGetMaxY(rect));\n    \n    // 关闭path\n    CGContextClosePath(ctx);\n    \n    // 4. 绘制 stroke fill\n//    CGContextFillPath(<#CGContextRef c#>)\n//    CGContextStrokePath(<#CGContextRef c#>)\n    CGContextDrawPath(ctx, kCGPathStroke);\n    \n    // 5. 回收资源\n    CGColorRelease(color);\n    CGColorSpaceRelease(colorSpace);\n}\n```\n\n- 效果图：\n![image](/images/Quartz2D/Line.png)\n\n- 要求：绘制矩形区域，以红线描边，绿色填充\n- 代码：\n\n```\n- (void)drawRect:(CGRect)rect\n{\n    // 获取上下文\n    CGContextRef ctx = UIGraphicsGetCurrentContext();\n    // 设置描边颜色\n    CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);\n    // 设置填充颜色\n    CGContextSetFillColorWithColor(ctx, [UIColor greenColor].CGColor);\n    // 设置线宽\n    CGContextSetLineWidth(ctx, 3);\n    // 添加矩形区域\n    CGContextAddRect(ctx, rect);\n    \n//    CGContextStrokePath(ctx);\n\t// 绘制区域以及线\n    CGContextDrawPath(ctx, kCGPathFillStroke);\n}\n```\n- 效果图：\n![image](/images/Quartz2D/Rect.png)\n\n- 要求：绘制弧线，以切线方法，最终绘制为一个直径为100的圆\n- 代码：\n\n```\n- (void)drawRect:(CGRect)rect\n{\n    // 获取上下文\n    CGContextRef ctx = UIGraphicsGetCurrentContext();\n    // 设置描边颜色\n    CGContextSetStrokeColorWithColor(ctx, [UIColor greenColor].CGColor);\n    \n    CGFloat x = rect.origin.x;\n    CGFloat y = 100;\n    // 移动画笔到第一个切点(以rect顶点为原点)\n    CGContextMoveToPoint(ctx, x, y);\n    // 确定两条切线交点位置，以及另一个切点位置\n    //CGContextAddArcToPoint(CGContextRef c, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius)\n    // c代表上下文，x1为交点x坐标，y1为交点y坐标，x2为第二切点的x，y2为第二切点的y，radius为弧线半径\n    CGContextAddArcToPoint(ctx, x, y+100, x+100, y+100, 100);\n    CGContextAddArcToPoint(ctx, x+200, y+100, x+200, y, 100);\n    CGContextAddArcToPoint(ctx, x+200, y-100, x+100, y-100, 100);\n    CGContextAddArcToPoint(ctx, x, y-100, x, y, 100);\n    // 绘制\n    CGContextStrokePath(ctx);\n}\n```\n- 效果图：\n![image](/images/Quartz2D/Arc.png)\n\n- 要求：绘制贝塞尔曲线\n- 代码：\n\n```\n- (void)drawRect:(CGRect)rect\n{\n\t// 获取上下文\n    CGContextRef ctx = UIGraphicsGetCurrentContext();\n    \n    CGContextSetStrokeColorWithColor(ctx, [UIColor blackColor].CGColor);\n    \n    CGFloat x = 0;\n    CGFloat y = 0;\n    \n    CGContextMoveToPoint(ctx, x, y);\n    \n    // CGContextAddCurveToPoint(CGContextRef c, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)\n    // cp1x，cp1y代表第一个贝塞尔参考点位置x和y，最后的xy代表终点位置\n    CGContextAddCurveToPoint(ctx, x+150, y+50, x+50, y+350, x+200, y+400);\n   //CGContextAddArcToPoint(ctx, x+150, y+50, x+200, y, 100);\n//    CGContextAddArcToPoint(ctx, x+200, y-100, x+100, y-100, 100);\n//    CGContextAddArcToPoint(ctx, x, y-100, x, y, 100);\n    \n    CGContextStrokePath(ctx);\n}\n```\n\n- 效果图：\n![image](/images/Quartz2D/curve.png)\n\n###三、UIBezierPath类\n1. 使用UIBezierPath类可以创建基于矢量的路径。此类是Core Graphics框架关于path的一个封装。使用此类可以定义简单的形状，如椭圆或者矩形，或者有多个直线和曲线段组成的形状。\n2. UIBezierPath对象是CGPathRef数据类型的封装。path如果是基于矢量形状的，都用直线和曲线段去创建。我们使用直线段去创建矩形和多边形，使用曲线段去创建弧（arc），圆或者其他复杂的曲线形状。每一段都包括一个或者多个点，绘图命令定义如何去诠释这些点。每一个直线段或者曲线段的结束的地方是下一个的开始的地方。每一个连接的直线或者曲线段的集合成为subpath。一个UIBezierPath对象定义一个完整的路径包括一个或者多个subpaths。\n3. 创建和使用一个path对象的过程是分开的。创建path是第一步，包含一下步骤：\n\t1. 创建一个path对象。\n\t2. 使用方法moveToPoint:去设置初始线段的起点。\n\t3. 添加line或者curve去定义一个或者多个subpaths。\n\t4. 改变UIBezierPath对象跟绘图相关的属性。例如，我们可以设置stroked path的属性lineWidth和lineJoinStyle。也可以设置filled path的属性usesEvenOddFillRule。\n- 要求：绘制圆角矩形，以及绘制不带箭尾的箭\n- 代码：\n\n```\n- (void)drawRect:(CGRect)rect\n{\n    // Drawing code\n    // 绘制圆角矩形\n    // 1. 创建bezier path\n    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(100, 50)];\n    // 2. 设置填充颜色\n    [[UIColor greenColor] setFill];\n    \n    // 3. 填充\n    [path fill];\n    /**\n     *  绘制不带箭尾的箭\n     *  UIBezierPath\n     */\n    \n    // 1. 黑色的箭shaft(轴)\n    UIBezierPath *p = [UIBezierPath bezierPath];\n    [p setLineWidth:20];\n    [p moveToPoint:CGPointMake(100, 100)];\n    [p addLineToPoint:CGPointMake(100, 25)];\n    [[UIColor blackColor] setStroke];\n    [p stroke];\n    \n    // 2. 红色的箭头(arrow)\n    [[UIColor redColor] setFill];\n    [p moveToPoint:CGPointMake(80, 25)];\n    [p addLineToPoint:CGPointMake(100, 0)];\n    [p addLineToPoint:CGPointMake(120, 25)];\n    [p fill];\n}\n```\n- 效果图：\n![image](/images/Quartz2D/bezierpath.png)\n\n- 要求：绘制渐变色箭尾的箭\n- 代码：\n```\n- (void)drawRect:(CGRect)rect\n{\n    // 坐标系转换(坐标原点转换到（80，0）位置)\n    CGContextTranslateCTM(ctx, 80, 0);\n    \n    // > 设置箭尾的三角区为不绘制区域(clipping)\n    // 保存初始状态\n    CGContextSaveGState(ctx);\n    \n    CGContextMoveToPoint(ctx, 10, 100);\n    CGContextAddLineToPoint(ctx, 20, 90);\n    CGContextAddLineToPoint(ctx, 30, 100);\n    // CGContextGetClipBoundingBox自动绘制一个包含上述三角形的矩形区域\n    CGRect flipRect = CGContextGetClipBoundingBox(ctx);\n    \n    CGContextAddRect(ctx, flipRect);\n    // 以奇偶填充法填充\n    CGContextEOClip(ctx);\n\n    // > 绘制箭杆\n    CGContextSetStrokeColorWithColor(ctx, [UIColor blackColor].CGColor);\n    CGContextSetLineWidth(ctx, 20);\n    \n    CGContextMoveToPoint(ctx, 20, 100);\n    CGContextAddLineToPoint(ctx, 20, 25);\n    // CGContextReplacePathWithStrokedPath将线转换为矩形区域\n    CGContextReplacePathWithStrokedPath(ctx);\n    \n    CGContextClip(ctx);\n    \n//    CGContextStrokePath(ctx);\n    \n    // 给shaft添加渐变\n    \n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    // 设置RGB以及Alpha\n    const CGFloat components[] = {0.6, 0.6, 0.6, 0.6,\n                                    0.0, 0.0, 0.0, 1.0,\n                                    0.6,0.6,0.6,0.6};\n    // 设置渐变位置\n    const CGFloat locations[] = {0, 0.618, 1};\n    \n    CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, components, locations, 3);\n    CGContextDrawLinearGradient(ctx, gradient, CGPointMake(10, 100), CGPointMake(30, 100), 0);\n    // 回到初始状态\n    CGContextRestoreGState(ctx);\n    // 回收颜色空间\n    CGColorSpaceRelease(colorSpace);\n    \n    // > 箭头\n    CGContextSetFillColorWithColor(ctx, [UIColor redColor].CGColor);\n    \n    CGContextMoveToPoint(ctx, 0, 25);\n    CGContextAddLineToPoint(ctx, 20, 0);\n    CGContextAddLineToPoint(ctx, 40, 25);\n    \n    CGContextFillPath(ctx);\n}\n```\n- 效果图：\n![image](/images/Quartz2D/arrowWithGradient.png)\n\n\n\n\t \n\n","slug":"iOS学习-Quartz2D使用","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid1zu000f3rtcfv7w07cg"},{"title":"iOS——ViewController生命周期","date":"2014-08-03T08:10:57.000Z","_content":"\n###view的加载\n\n1. ViewController在我们开发中经常用到，它的职责主要包括管理内部各个view的加载显示和卸载，同时负责与其他ViewController的通信和协调。\n2. 在iOS中，有两类Viewcontroller，一类是显示内容的，比如UIViewController、UITableViewController等，同时还可以自定义集成自UIViewController的XXXViewController；另一类是ViewController容器，UINavigationController和UITabBarController等，UINavigationViewController是以Stack的形式来存储和管理ViewController，UITabBarController是以Array的形式来管理Viewcontroller。和Android中Activity一样，iOS开发中，ViewController也有自己的生命周期\n3. 首先我们来看看View的加载过程，如下图：\n\n\t![image](/images/ViewController/1.png)\n\t\n\t> 从图中可以看出，在view加载过程中首先会调用loadView方法，在这个方法中主要完成一些关键view的初始化工作，比如UINavigationController和UITabBarController等容器类的ViewController；接下来就是加载View，加载成功后，会接着调用ViewDidLoad方法，`注意:在loadView之前，是没有View的，也就是说，在这之前，view还没有被初始化。`完成viewDidLoad方法后，ViewController里面就成功加载view了，如上图有下角所示。\n\n4. 在Controller中创建view有两种方式，一种是通过代码创建、一种是通过storyboard或interface builder来创建，后者可以比较直观的配置view的外观和属性，storyboard配合iOS6推出的AutoLayout，应该是Apple之后主推的一种UI定制解决方案。\n\n###view的卸载\n\n5. 我们来看一下view是如何被卸载的\n\t\n\t![image](/images/ViewController/2.png)\n\n\t> 由上图可以看出，当系统给发出内存警告时，会调用didReceiveMemoeryWarning方法，如果当前有能被释放的View，系统会调用viewWillUnload方法来释放view，完成后调用viewDidUnload，至此，view就被卸载了。此时原本指向view的变量要被置为nil，具体操作是在viewDidUnload方法中调用self。XXX = nil；\n\n###小结\n\n6. loadView和viewDidLoad的区别就是，loadView时view还没有生成，viewDidLoad时，view已经生成了，loadView以及viewDidLoad只会被调用一次，因为view是被懒加载的，当再次访问view时，view已存在，就不会在执行loadView和viewDidLoad，当view被添加到其他view中之前，会调用viewWillAppear，之后会调用viewDidAppear。当view从其他view中移除之前，调用viewWillDisAppear，移除之后会调用viewDidDisappear。当view不再使用时，受到内存警告时，ViewController会将view释放并将其指向为nil。\n7. ViewController的生命周期中各方法执行流程如下：\ninit—>loadView—>viewDidLoad—>viewWillApper—>viewDidApper—>viewWillDisapper—>viewDidDisapper—>viewWillUnload->viewDidUnload—>dealloc\n \n\n","source":"_posts/iOS——ViewController生命周期.md","raw":"title: \"iOS——ViewController生命周期\"\ndate: 2014-08-03 16:10:57\ntags: viewController生命周期\n---\n\n###view的加载\n\n1. ViewController在我们开发中经常用到，它的职责主要包括管理内部各个view的加载显示和卸载，同时负责与其他ViewController的通信和协调。\n2. 在iOS中，有两类Viewcontroller，一类是显示内容的，比如UIViewController、UITableViewController等，同时还可以自定义集成自UIViewController的XXXViewController；另一类是ViewController容器，UINavigationController和UITabBarController等，UINavigationViewController是以Stack的形式来存储和管理ViewController，UITabBarController是以Array的形式来管理Viewcontroller。和Android中Activity一样，iOS开发中，ViewController也有自己的生命周期\n3. 首先我们来看看View的加载过程，如下图：\n\n\t![image](/images/ViewController/1.png)\n\t\n\t> 从图中可以看出，在view加载过程中首先会调用loadView方法，在这个方法中主要完成一些关键view的初始化工作，比如UINavigationController和UITabBarController等容器类的ViewController；接下来就是加载View，加载成功后，会接着调用ViewDidLoad方法，`注意:在loadView之前，是没有View的，也就是说，在这之前，view还没有被初始化。`完成viewDidLoad方法后，ViewController里面就成功加载view了，如上图有下角所示。\n\n4. 在Controller中创建view有两种方式，一种是通过代码创建、一种是通过storyboard或interface builder来创建，后者可以比较直观的配置view的外观和属性，storyboard配合iOS6推出的AutoLayout，应该是Apple之后主推的一种UI定制解决方案。\n\n###view的卸载\n\n5. 我们来看一下view是如何被卸载的\n\t\n\t![image](/images/ViewController/2.png)\n\n\t> 由上图可以看出，当系统给发出内存警告时，会调用didReceiveMemoeryWarning方法，如果当前有能被释放的View，系统会调用viewWillUnload方法来释放view，完成后调用viewDidUnload，至此，view就被卸载了。此时原本指向view的变量要被置为nil，具体操作是在viewDidUnload方法中调用self。XXX = nil；\n\n###小结\n\n6. loadView和viewDidLoad的区别就是，loadView时view还没有生成，viewDidLoad时，view已经生成了，loadView以及viewDidLoad只会被调用一次，因为view是被懒加载的，当再次访问view时，view已存在，就不会在执行loadView和viewDidLoad，当view被添加到其他view中之前，会调用viewWillAppear，之后会调用viewDidAppear。当view从其他view中移除之前，调用viewWillDisAppear，移除之后会调用viewDidDisappear。当view不再使用时，受到内存警告时，ViewController会将view释放并将其指向为nil。\n7. ViewController的生命周期中各方法执行流程如下：\ninit—>loadView—>viewDidLoad—>viewWillApper—>viewDidApper—>viewWillDisapper—>viewDidDisapper—>viewWillUnload->viewDidUnload—>dealloc\n \n\n","slug":"iOS——ViewController生命周期","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid1zw000i3rtcvj4gm3lo"},{"title":"iOS--Pch文件的使用","date":"2014-09-08T06:13:53.000Z","_content":"\n###Xcode6添加pch文件\n\n`前言：`Xcode6中不在为开发者自动创建pch文件，在pch文件中我们可以添加一些琐碎的宏定义，在项目中任何地方都可以引用，加快了编译的速度\n\n1. Xcode6之后的版本都是需要自己添加的,步骤如下：\n\n\t![image](/images/pch/1.png)\n\t\n2. 随后需要进行一些配置\n\n\t![image](/images/pch/2.png)\n\t\n\t在上图中的第三步Prefix Header的值进行设置时最好使用\n\t`$(SRCROOT)/工程名/pch文件名`\n\t相对路径的书写方法，不要写成绝对路径，如果使用绝对路径会出现一些问题。","source":"_posts/iOS-Pch文件的使用.md","raw":"title: \"iOS--Pch文件的使用\"\ndate: 2014-09-08 14:13:53\ntags: .Pch文件\n---\n\n###Xcode6添加pch文件\n\n`前言：`Xcode6中不在为开发者自动创建pch文件，在pch文件中我们可以添加一些琐碎的宏定义，在项目中任何地方都可以引用，加快了编译的速度\n\n1. Xcode6之后的版本都是需要自己添加的,步骤如下：\n\n\t![image](/images/pch/1.png)\n\t\n2. 随后需要进行一些配置\n\n\t![image](/images/pch/2.png)\n\t\n\t在上图中的第三步Prefix Header的值进行设置时最好使用\n\t`$(SRCROOT)/工程名/pch文件名`\n\t相对路径的书写方法，不要写成绝对路径，如果使用绝对路径会出现一些问题。","slug":"iOS-Pch文件的使用","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid1zy000l3rtc5jtkcpai"},{"title":"Xcode已安装插件的删除","date":"2014-08-12T05:16:29.000Z","_content":"\n1. 首先进入iterm编辑器中，在home下输入如下命令：\n\n\t```\n\t$ Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/\n\t```\n\n2. 进入该文件夹下，你可以看到你所装的所有的插件，这是你想删除那个直接将那个文件夹删除就行了，什么？！你不知道怎么删除文件夹，好吧，你按如下操作就可以删除了，不过删除时你要小心了哦，`这个命令可是不会提醒你要删除哪个文件的`，请务必确认好你要删除的文件，删错了就不好了。\n\n\t```\n\t$ rm -rf 文件名\n\t```","source":"_posts/Xcode已安装插件的删除.md","raw":"title: \"Xcode已安装插件的删除\"\ndate: 2014-08-12 13:16:29\ntags: Xcode插件删除\n---\n\n1. 首先进入iterm编辑器中，在home下输入如下命令：\n\n\t```\n\t$ Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/\n\t```\n\n2. 进入该文件夹下，你可以看到你所装的所有的插件，这是你想删除那个直接将那个文件夹删除就行了，什么？！你不知道怎么删除文件夹，好吧，你按如下操作就可以删除了，不过删除时你要小心了哦，`这个命令可是不会提醒你要删除哪个文件的`，请务必确认好你要删除的文件，删错了就不好了。\n\n\t```\n\t$ rm -rf 文件名\n\t```","slug":"Xcode已安装插件的删除","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid200000o3rtc4fyrm3fu"},{"title":"XML&JSON","date":"2014-03-14T05:15:27.000Z","_content":"###XML\n\n####SAX解析\n\n```\n    // 1. 获取XML文件的URL\n    NSURL *fileURL = [[NSBundle mainBundle] URLForResource:@\"bookstore\" withExtension:@\"xml\"];\n    \n    // 2. 创建xml解析器对象\n    NSXMLParser *xmlParser = [[NSXMLParser alloc] initWithContentsOfURL:fileURL];\n    \n    // 3. 设置代理\n    xmlParser.delegate = self;\n    \n    // 4. 开始解析\n    BOOL result = [xmlParser parse];\n    if (!result) {\n        NSLog(@\"xmlParser parse error!\");\n        return;\n    }\n```\n---\n\nNSXMLperser对象代理方法： \n  \n- \\- (void)parserDidStartDocument:(NSXMLParser *)parser\n> 当开始解析XML文档的时候，调用这个方法。通常在这个方法里，`创建存储模型对象的数组`\n\n- \\- (void)parser:(NSXMLParser )parser didStartElement:(NSString )elementName namespaceURI:(NSString )namespaceURI qualifiedName:(NSString )qName attributes:(NSDictionary *)attributeDict\n> 当开始解析，遇到语速标签的时候，调用这个方法。通常在这个方法里，`创建模型对象或解析标签中的属性保存在模型对象中`\n\n- \\- (void)parser:(NSXMLParser )parser foundCharacters:(NSString )string\n> 当解析到xml标签的文本内容的时候，调用这个方法，通常在这里先`暂存解析到的内容文本内容`\n\n- \\- (void)parser:(NSXMLParser )parser didEndElement:(NSString )elementName namespaceURI:(NSString )namespaceURI qualifiedName:(NSString )qName\n> 当解析xml内容遇到结束标签的时候，调用这个方法。通常在这个方法里，`需要将模型对象保存入数组中或把标签对应的文本内容解析出来，保存在模型对象中（KVC）`\n\n- \\- (void)parserDidEndDocument:(NSXMLParser *)parser\n> 当整个xml文档全部解析结束的时候，该方法会调用\n\n- \\- (void)parser:(NSXMLParser )parser parseErrorOccurred:(NSError )parseError\n> 当遇到解析错误时，该方法会被调用\n\n---\n\n###DOM解析（以GDataXMLNode为例）\n\n####使用：\n\n添加头文件搜索路径：`Build Settings->Header Search Paths->\"/usr/include/libxml2\"`\n用非ARC的方式编译GDataXMLNode.m文件：`-fno-objc-arc`\n链接libxml2.dylib该动态库：`Build Phases->Link Binary With Libraries->“libxml2.dylib”`\n\n```\n\t/* <节点> (GDataXMLNode)\n\t * 根据DOM，XML文档中的每个成分都是一个节点。\n\t * DOM是这样规定的：\n\t * 整个文档是一个文档节点\n\t * 每个XML标签是一个元素节点\n\t * 包含在XML元素中的文本是文本节点\n\t * 每一个XML属性是一个属性节点\n\t * 注释属于注释节点\n\t */\n```\n1. 根据XML文件创建NSData对象\n\t\n\t```\n    // 1. 创建数组对象\n    _bookstore = [NSMutableArray array];\n    \n    // 2. 获取XML文件的URL\n    NSURL *fileURL = [[NSBundle mainBundle] URLForResource:@\"bookstore\" withExtension:@\"xml\"];\n    \n    // 3. 根据URL路径，将文件读取到内存中\n    NSData *data = [NSData dataWithContentsOfURL:fileURL];\n\t```\n\n2. 根据NSData对象创建GDataXMLDocument对象（即DOM模型对象），该对象在内存中是以树形结构存储的\n\t\n\t```\n    // 4. 创建DOM文件模型对象\n    GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data options:0 error:nil];\n\t```\n\n3. 通过DOM模型对象，取出XML文件的根元素\n\n\t```\n    // 5. 取出xml DOM🌲中根元素\n    GDataXMLElement *rootElement = [doc rootElement];\n\t```\n4. 由于是树形结构，所以可以根据子元素的名字使用根元素获取到所有子元素，兵类推获得子元素的子元素\n\n\t```\n    NSArray *books = [rootElement elementsForName:kBook];\n    \n    NSLog(@\"%@\", books);\n    \n    for (GDataXMLElement *element in books) {\n        // 创建图书对象\n        QYBook *book = [[QYBook alloc] init];\n        \n        // 根据属性名字，解析出book中的属性值\n        book.category = [[element attributeForName:kCategory] stringValue];\n        \n        // 解析title元素\n        GDataXMLElement * titleElement = [element elementsForName:kTitle][0];\n        book.lang = [[titleElement attributeForName:kLang] stringValue];\n        book.title = [titleElement stringValue];\n        \n        // 解析author元素\n        GDataXMLElement *authorElement = [element elementsForName:kAuthor][0];\n        book.author = [authorElement stringValue];\n        \n        // 解析price元素\n        GDataXMLElement *priceElement = [element elementsForName:kPrice][0];\n        book.price = [priceElement stringValue];\n        [_bookstore addObject:book];\n    }\n\t```\n---\n\n###JSON\n\n从结构上看，所有的数据（data）最终都可以分解成三种类型：\n   \n- 第一种类型是标量（scalar），也就是一个单独的字符创（string）或数字（numbers），比如“北京”这个单独的词\n- 第二种类型是序列（sequence），也就是若干个相关的数据按照一定顺序并列在一起，又叫做数组（array）或列表（List），比如“北京，上海”\n- 第三种类型是映射（mapping），也就是一个名/值对（Name/value），即数据有一个名称，还有一个与之相对应的值，这又称作散列（hash）活字典（dictionary），比如“首都:北京”\n\nDouglas Crockford发明了JSON，Json的规定非常简单\n\t\n\t1. 并列的数据之间用逗号（,）分隔\n\t2. 映射用冒号（:）表示\n\t3. 并列数据的集合（数组）用方括号（[]）表示\n\t4. 映射的集合（对象）用大括号（{}）表示\n\n比如，下面这句话：\n> \"北京市的面积为16800平方公里，常住人口1600万人。上海市的面积为6400平方公里，常住人口1800万。\"\n\n写成JSON格式就是这样：\n\t\n\t[\n\t\t{\"城市\":\"北京\",\"面积\":16800,\"人口\":1600},\n\t\t{\"城市\":\"上海\",\"面积\":6400,\"人口\":1800}\n\t]\n\t\n如果事先知道数据的结构，上面的写法还可以进一步简化：\n\t\n\t[\n\t\t[\"北京\",16800,1600],\n\t\t[\"上海\",6400,1800]\n\t]\n\t\n`介绍JSON格式定义：` `rfc-4627`\n[介绍JSON](http://www.json.org/json-zh.htm)\n[JSON格式化工具](http://www.sojson.com)\n\n####NSJSONSerialization\n\n\t+ (id)JSONObjectWithData:(NSData *)data options:(NSJSONReadingOptions)opt error:(NSError **)error\n\t+ (NSData *)dataWithJSONObject:(id)obj options:(NSJSONWritingOptions)opt error:(NSError **)error\n\n####JSONKit\n\n使用：`-fno-objc-arc`\n序列化：`NSArray` `NSDictionary` `NSString`\n\n\t- JSONData\n\t- JSONDataWithOptions:includeQuotes:error:\n\t- JSONDataWithOptions:serializeUnsupportedClassesUsingDelegate:selector:error:\n\t-JSONDataWithOptions:serializeUnsupportedClassesUsingBlock:error:￼\n\t\n\t- JSONString\n\t- JSONStringWithOptions:includeQuotes:error:\n\t- JSONStringWithOptions:serializeUnsupportedClassesUsingDelegate:selector:error:\n\t- JSONStringWithOptions:serializeUnsupportedClassesUsinBlock:error:\n\n反序列化：`NSData` `NSString`\n\n\t- objectFromJSONData\n\t- objectFromJSONDataWithParseOptions:\n\t- objectFromJSONDataWithParseOptions:error:\n\t- mutableObjectFromJSONData\n\t- mutableObjectFromJSONDataWithParseOptions:\n\t- mubtableObjectFromJSONDataWithParseOptions:error:\n\t\n\t- objectFromJSONString\n\t- objectFromJSONStringWithParseOptions:\n\t- objectFromJSONStringWithParseOptions:error:\n\t- mutableObjectFromJSONString\n\t- mutableObjectFromJSONStringWithParseOptions:\n\t- mutableObjectFromJSONStringWithParseOptions:error:\n\n####例子：\n\n- 要求：解析jsonData中的json数据\n- 代码：\n\n```\n\n    NSURL *url = [[NSBundle mainBundle] URLForResource:@\"JsonData\" withExtension:@\"json\"];\n    \n    NSData *data = [NSData dataWithContentsOfURL:url];\n    \n    // JSON解析 （反序列化）\n    id obj = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers|NSJSONReadingMutableLeaves|NSJSONReadingAllowFragments error:nil];\n    if ([obj isKindOfClass:[NSMutableArray class]]) {\n        NSLog(@\"Array!\");\n    } else if ([obj isKindOfClass:[NSMutableDictionary class]]) {\n        NSLog(@\"Dictionary!\");\n    } else {\n        NSLog(@\"Other!\");\n    }\n    \n    NSLog(@\"%@\", obj);\n    \n    NSLog(@\"0's city:%@\", [obj[0] objectForKey:@\"City\"]);\n    \n    // 创建 JSON data （序列化）\n    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:obj options:NSJSONWritingPrettyPrinted error:nil];\n    \n//    NSLog(@\"%@\", jsonData);\n    NSString *jsonStr = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];\n    NSLog(@\"jsonStr:%@\", jsonStr);\n```","source":"_posts/XML-JSON.md","raw":"title: \"XML&JSON\"\ndate: 2014-03-14 13:15:27\ntags: XML&JSON\n---\n###XML\n\n####SAX解析\n\n```\n    // 1. 获取XML文件的URL\n    NSURL *fileURL = [[NSBundle mainBundle] URLForResource:@\"bookstore\" withExtension:@\"xml\"];\n    \n    // 2. 创建xml解析器对象\n    NSXMLParser *xmlParser = [[NSXMLParser alloc] initWithContentsOfURL:fileURL];\n    \n    // 3. 设置代理\n    xmlParser.delegate = self;\n    \n    // 4. 开始解析\n    BOOL result = [xmlParser parse];\n    if (!result) {\n        NSLog(@\"xmlParser parse error!\");\n        return;\n    }\n```\n---\n\nNSXMLperser对象代理方法： \n  \n- \\- (void)parserDidStartDocument:(NSXMLParser *)parser\n> 当开始解析XML文档的时候，调用这个方法。通常在这个方法里，`创建存储模型对象的数组`\n\n- \\- (void)parser:(NSXMLParser )parser didStartElement:(NSString )elementName namespaceURI:(NSString )namespaceURI qualifiedName:(NSString )qName attributes:(NSDictionary *)attributeDict\n> 当开始解析，遇到语速标签的时候，调用这个方法。通常在这个方法里，`创建模型对象或解析标签中的属性保存在模型对象中`\n\n- \\- (void)parser:(NSXMLParser )parser foundCharacters:(NSString )string\n> 当解析到xml标签的文本内容的时候，调用这个方法，通常在这里先`暂存解析到的内容文本内容`\n\n- \\- (void)parser:(NSXMLParser )parser didEndElement:(NSString )elementName namespaceURI:(NSString )namespaceURI qualifiedName:(NSString )qName\n> 当解析xml内容遇到结束标签的时候，调用这个方法。通常在这个方法里，`需要将模型对象保存入数组中或把标签对应的文本内容解析出来，保存在模型对象中（KVC）`\n\n- \\- (void)parserDidEndDocument:(NSXMLParser *)parser\n> 当整个xml文档全部解析结束的时候，该方法会调用\n\n- \\- (void)parser:(NSXMLParser )parser parseErrorOccurred:(NSError )parseError\n> 当遇到解析错误时，该方法会被调用\n\n---\n\n###DOM解析（以GDataXMLNode为例）\n\n####使用：\n\n添加头文件搜索路径：`Build Settings->Header Search Paths->\"/usr/include/libxml2\"`\n用非ARC的方式编译GDataXMLNode.m文件：`-fno-objc-arc`\n链接libxml2.dylib该动态库：`Build Phases->Link Binary With Libraries->“libxml2.dylib”`\n\n```\n\t/* <节点> (GDataXMLNode)\n\t * 根据DOM，XML文档中的每个成分都是一个节点。\n\t * DOM是这样规定的：\n\t * 整个文档是一个文档节点\n\t * 每个XML标签是一个元素节点\n\t * 包含在XML元素中的文本是文本节点\n\t * 每一个XML属性是一个属性节点\n\t * 注释属于注释节点\n\t */\n```\n1. 根据XML文件创建NSData对象\n\t\n\t```\n    // 1. 创建数组对象\n    _bookstore = [NSMutableArray array];\n    \n    // 2. 获取XML文件的URL\n    NSURL *fileURL = [[NSBundle mainBundle] URLForResource:@\"bookstore\" withExtension:@\"xml\"];\n    \n    // 3. 根据URL路径，将文件读取到内存中\n    NSData *data = [NSData dataWithContentsOfURL:fileURL];\n\t```\n\n2. 根据NSData对象创建GDataXMLDocument对象（即DOM模型对象），该对象在内存中是以树形结构存储的\n\t\n\t```\n    // 4. 创建DOM文件模型对象\n    GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data options:0 error:nil];\n\t```\n\n3. 通过DOM模型对象，取出XML文件的根元素\n\n\t```\n    // 5. 取出xml DOM🌲中根元素\n    GDataXMLElement *rootElement = [doc rootElement];\n\t```\n4. 由于是树形结构，所以可以根据子元素的名字使用根元素获取到所有子元素，兵类推获得子元素的子元素\n\n\t```\n    NSArray *books = [rootElement elementsForName:kBook];\n    \n    NSLog(@\"%@\", books);\n    \n    for (GDataXMLElement *element in books) {\n        // 创建图书对象\n        QYBook *book = [[QYBook alloc] init];\n        \n        // 根据属性名字，解析出book中的属性值\n        book.category = [[element attributeForName:kCategory] stringValue];\n        \n        // 解析title元素\n        GDataXMLElement * titleElement = [element elementsForName:kTitle][0];\n        book.lang = [[titleElement attributeForName:kLang] stringValue];\n        book.title = [titleElement stringValue];\n        \n        // 解析author元素\n        GDataXMLElement *authorElement = [element elementsForName:kAuthor][0];\n        book.author = [authorElement stringValue];\n        \n        // 解析price元素\n        GDataXMLElement *priceElement = [element elementsForName:kPrice][0];\n        book.price = [priceElement stringValue];\n        [_bookstore addObject:book];\n    }\n\t```\n---\n\n###JSON\n\n从结构上看，所有的数据（data）最终都可以分解成三种类型：\n   \n- 第一种类型是标量（scalar），也就是一个单独的字符创（string）或数字（numbers），比如“北京”这个单独的词\n- 第二种类型是序列（sequence），也就是若干个相关的数据按照一定顺序并列在一起，又叫做数组（array）或列表（List），比如“北京，上海”\n- 第三种类型是映射（mapping），也就是一个名/值对（Name/value），即数据有一个名称，还有一个与之相对应的值，这又称作散列（hash）活字典（dictionary），比如“首都:北京”\n\nDouglas Crockford发明了JSON，Json的规定非常简单\n\t\n\t1. 并列的数据之间用逗号（,）分隔\n\t2. 映射用冒号（:）表示\n\t3. 并列数据的集合（数组）用方括号（[]）表示\n\t4. 映射的集合（对象）用大括号（{}）表示\n\n比如，下面这句话：\n> \"北京市的面积为16800平方公里，常住人口1600万人。上海市的面积为6400平方公里，常住人口1800万。\"\n\n写成JSON格式就是这样：\n\t\n\t[\n\t\t{\"城市\":\"北京\",\"面积\":16800,\"人口\":1600},\n\t\t{\"城市\":\"上海\",\"面积\":6400,\"人口\":1800}\n\t]\n\t\n如果事先知道数据的结构，上面的写法还可以进一步简化：\n\t\n\t[\n\t\t[\"北京\",16800,1600],\n\t\t[\"上海\",6400,1800]\n\t]\n\t\n`介绍JSON格式定义：` `rfc-4627`\n[介绍JSON](http://www.json.org/json-zh.htm)\n[JSON格式化工具](http://www.sojson.com)\n\n####NSJSONSerialization\n\n\t+ (id)JSONObjectWithData:(NSData *)data options:(NSJSONReadingOptions)opt error:(NSError **)error\n\t+ (NSData *)dataWithJSONObject:(id)obj options:(NSJSONWritingOptions)opt error:(NSError **)error\n\n####JSONKit\n\n使用：`-fno-objc-arc`\n序列化：`NSArray` `NSDictionary` `NSString`\n\n\t- JSONData\n\t- JSONDataWithOptions:includeQuotes:error:\n\t- JSONDataWithOptions:serializeUnsupportedClassesUsingDelegate:selector:error:\n\t-JSONDataWithOptions:serializeUnsupportedClassesUsingBlock:error:￼\n\t\n\t- JSONString\n\t- JSONStringWithOptions:includeQuotes:error:\n\t- JSONStringWithOptions:serializeUnsupportedClassesUsingDelegate:selector:error:\n\t- JSONStringWithOptions:serializeUnsupportedClassesUsinBlock:error:\n\n反序列化：`NSData` `NSString`\n\n\t- objectFromJSONData\n\t- objectFromJSONDataWithParseOptions:\n\t- objectFromJSONDataWithParseOptions:error:\n\t- mutableObjectFromJSONData\n\t- mutableObjectFromJSONDataWithParseOptions:\n\t- mubtableObjectFromJSONDataWithParseOptions:error:\n\t\n\t- objectFromJSONString\n\t- objectFromJSONStringWithParseOptions:\n\t- objectFromJSONStringWithParseOptions:error:\n\t- mutableObjectFromJSONString\n\t- mutableObjectFromJSONStringWithParseOptions:\n\t- mutableObjectFromJSONStringWithParseOptions:error:\n\n####例子：\n\n- 要求：解析jsonData中的json数据\n- 代码：\n\n```\n\n    NSURL *url = [[NSBundle mainBundle] URLForResource:@\"JsonData\" withExtension:@\"json\"];\n    \n    NSData *data = [NSData dataWithContentsOfURL:url];\n    \n    // JSON解析 （反序列化）\n    id obj = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers|NSJSONReadingMutableLeaves|NSJSONReadingAllowFragments error:nil];\n    if ([obj isKindOfClass:[NSMutableArray class]]) {\n        NSLog(@\"Array!\");\n    } else if ([obj isKindOfClass:[NSMutableDictionary class]]) {\n        NSLog(@\"Dictionary!\");\n    } else {\n        NSLog(@\"Other!\");\n    }\n    \n    NSLog(@\"%@\", obj);\n    \n    NSLog(@\"0's city:%@\", [obj[0] objectForKey:@\"City\"]);\n    \n    // 创建 JSON data （序列化）\n    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:obj options:NSJSONWritingPrettyPrinted error:nil];\n    \n//    NSLog(@\"%@\", jsonData);\n    NSString *jsonStr = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];\n    NSLog(@\"jsonStr:%@\", jsonStr);\n```","slug":"XML-JSON","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid202000r3rtc94a0jxry"},{"title":"UINavigationController详解与使用（二）页面切换及ToolBar","date":"2014-04-17T11:45:18.000Z","_content":"\n####页面跳转\n\n1. RootView跳到SecondView\n\n\t首先我们需要新的一个View。新建SecondView，按住Command键然后按N，弹出新建页面，我们新建SecondView\n\t\n\t![image](/images/UINavigationVC/10.png)\n\n2. 为Button添加点击事件，实现跳转\n\n\t在RootViewController.xib中和RootViewController.h文件建立连接\n\t![image](/images/UINavigationVC/11.png)\n\n\t在RootViewController.m中实现代码，alloc一个SecondViewController，用pushViewController到navigationController中去，并为SecondViewController这时title为secondView.title = @\"Second View\";默认情况下，title为下个页面返回按钮的名字。\n\t\n\t```\n\t- (IBAction)gotoSecondView:(id)sender {\n    SecondViewController *secondView = [[SecondViewController alloc] init];\n    [self.navigationController pushViewController:secondView animated:YES];\n    secondView.title = @\"Second View\";\n\t}\n\t```\n\n\t这是点击GotoSecondView按钮，出现\n\t![image](/images/UINavigationVC/12.png)\n\n3. 自定义backBarButtonItem\n\n\t左上角的返回上级View的barButtonItem的名字是上级目录的Title，如果title或者适合做button的名字，怎么办呢？我们可以自定义\n\t代码如下：\n\t\n\t```\n\t UIBarButtonItem *backButton = [[UIBarButtonItem alloc] initWithTitle:@\"根视图\" style:UIBarButtonItemStyleDone target:nil action:nil];\n    self.navigationItem.backBarButton = backButton;\n\t```\n\t效果:\n\t![image](/images/UINavigationVC/13.png)\n\n####ToolBar\n\n1. 显示ToolBar\n\n\t在RootViewController.m的`-(void)viewDidLoad`方法中添加代码，这样Toobar就显示出来了\n\t>[self.navigationController setToolbarHidden:NO animated:YES];\n\n2. 在ToolBar上添加UIBarButtonItem\n\n\t新建几个UIBarButtonItem，然后以数组的形式添加到Toolbar中\n\t\n\t```\n\tUIBarButtonItem *one = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAdd target:nil action:nil];\n\tUIBarButtonItem *two = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemBookmarks target:nil action:nil];\n\tUIBarButtonItem *three = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAction target:nil action:nil];\n\tUIBarButtonItem *four = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemEdit target:nil action:nil];\n\tUIBarButtonItem *flexItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil];\n\t[self setToolbarItems:[NSArray arrayWithObjects:flexItem, one, flexItem, two, flexItem, three, flexItem, four, flexItem, nil]];\n\t```\n\t效果如下：\n\t![image](/images/UINavigationVC/14.png)\n\n\t`注意：`用[self.navigationController.toolbar setItems:(NSArray *)animated:YES]这个方法添加Item是不起效果的。下面需要自己动态添加Toolbar时，这个才起效果。\n\n3. 动态添加ToolBar\n\n\t我们在SecondView添加动态的ToolBar\n\t在SecondViewController.h添加\n\t\n\t```\n\t#import <UIKit/UIKit.h>\n\n\t@interface SecondViewController : UIViewController\n\t{\n\t    UIToolbar *toolBar;\n\t}\n\t@end\n\n\t```\n\n\t在SecondViewController.m添加\n\t\n\t```\n\t- (void)viewDidLoad\n\t{\n\t    [super viewDidLoad];\n\t\n\t    [self.navigationController  setToolbarHidden:YES animated:YES];\n\t\t\n\t    UIBarButtonItem *addButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemSearch target:self action:@selector(gotoThridView:)];\n\t    toolBar = [[UIToolbar alloc] initWithFrame:CGRectMake(0.0, self.view.frame.size.height - toolBar.frame.size.height - 44.0, self.view.frame.size.width, 44.0)];\n\t    [toolBar setBarStyle:UIBarStyleDefault];\n\t    toolBar.autoresizingMask = UIViewAutoresizingFlexibleTopMargin;\n\t    [toolBar setItems:[NSArray arrayWithObject:addButton]];\n\t    [self.view addSubview:toolBar];\n\t     \n\t    // Do any additional setup after loading the view from its nib.\n\t}\n\t```\n\t以上我觉得移除自带的Toolbar而不是将其隐藏\n\t[self.navigationController.toolbar removeFromSuperview];\n","source":"_posts/UINavigationController详解与使用（二）页面切换及ToolBar.md","raw":"title: \"UINavigationController详解与使用（二）页面切换及ToolBar\"\ndate: 2014-04-17 19:45:18\ntags: ToolBar\n---\n\n####页面跳转\n\n1. RootView跳到SecondView\n\n\t首先我们需要新的一个View。新建SecondView，按住Command键然后按N，弹出新建页面，我们新建SecondView\n\t\n\t![image](/images/UINavigationVC/10.png)\n\n2. 为Button添加点击事件，实现跳转\n\n\t在RootViewController.xib中和RootViewController.h文件建立连接\n\t![image](/images/UINavigationVC/11.png)\n\n\t在RootViewController.m中实现代码，alloc一个SecondViewController，用pushViewController到navigationController中去，并为SecondViewController这时title为secondView.title = @\"Second View\";默认情况下，title为下个页面返回按钮的名字。\n\t\n\t```\n\t- (IBAction)gotoSecondView:(id)sender {\n    SecondViewController *secondView = [[SecondViewController alloc] init];\n    [self.navigationController pushViewController:secondView animated:YES];\n    secondView.title = @\"Second View\";\n\t}\n\t```\n\n\t这是点击GotoSecondView按钮，出现\n\t![image](/images/UINavigationVC/12.png)\n\n3. 自定义backBarButtonItem\n\n\t左上角的返回上级View的barButtonItem的名字是上级目录的Title，如果title或者适合做button的名字，怎么办呢？我们可以自定义\n\t代码如下：\n\t\n\t```\n\t UIBarButtonItem *backButton = [[UIBarButtonItem alloc] initWithTitle:@\"根视图\" style:UIBarButtonItemStyleDone target:nil action:nil];\n    self.navigationItem.backBarButton = backButton;\n\t```\n\t效果:\n\t![image](/images/UINavigationVC/13.png)\n\n####ToolBar\n\n1. 显示ToolBar\n\n\t在RootViewController.m的`-(void)viewDidLoad`方法中添加代码，这样Toobar就显示出来了\n\t>[self.navigationController setToolbarHidden:NO animated:YES];\n\n2. 在ToolBar上添加UIBarButtonItem\n\n\t新建几个UIBarButtonItem，然后以数组的形式添加到Toolbar中\n\t\n\t```\n\tUIBarButtonItem *one = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAdd target:nil action:nil];\n\tUIBarButtonItem *two = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemBookmarks target:nil action:nil];\n\tUIBarButtonItem *three = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAction target:nil action:nil];\n\tUIBarButtonItem *four = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemEdit target:nil action:nil];\n\tUIBarButtonItem *flexItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil];\n\t[self setToolbarItems:[NSArray arrayWithObjects:flexItem, one, flexItem, two, flexItem, three, flexItem, four, flexItem, nil]];\n\t```\n\t效果如下：\n\t![image](/images/UINavigationVC/14.png)\n\n\t`注意：`用[self.navigationController.toolbar setItems:(NSArray *)animated:YES]这个方法添加Item是不起效果的。下面需要自己动态添加Toolbar时，这个才起效果。\n\n3. 动态添加ToolBar\n\n\t我们在SecondView添加动态的ToolBar\n\t在SecondViewController.h添加\n\t\n\t```\n\t#import <UIKit/UIKit.h>\n\n\t@interface SecondViewController : UIViewController\n\t{\n\t    UIToolbar *toolBar;\n\t}\n\t@end\n\n\t```\n\n\t在SecondViewController.m添加\n\t\n\t```\n\t- (void)viewDidLoad\n\t{\n\t    [super viewDidLoad];\n\t\n\t    [self.navigationController  setToolbarHidden:YES animated:YES];\n\t\t\n\t    UIBarButtonItem *addButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemSearch target:self action:@selector(gotoThridView:)];\n\t    toolBar = [[UIToolbar alloc] initWithFrame:CGRectMake(0.0, self.view.frame.size.height - toolBar.frame.size.height - 44.0, self.view.frame.size.width, 44.0)];\n\t    [toolBar setBarStyle:UIBarStyleDefault];\n\t    toolBar.autoresizingMask = UIViewAutoresizingFlexibleTopMargin;\n\t    [toolBar setItems:[NSArray arrayWithObject:addButton]];\n\t    [self.view addSubview:toolBar];\n\t     \n\t    // Do any additional setup after loading the view from its nib.\n\t}\n\t```\n\t以上我觉得移除自带的Toolbar而不是将其隐藏\n\t[self.navigationController.toolbar removeFromSuperview];\n","slug":"UINavigationController详解与使用（二）页面切换及ToolBar","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid204000u3rtcp7omuezc"},{"title":"UINavigationController详解与使用（一）添加UIButtonItem","date":"2014-04-17T08:39:03.000Z","_content":"\n####UINavigationController导航控制器如何使用\n\n1. UINavigationController可以翻译为导航控制器，在iOS里经常用到。\n\n\t我们看看它如何使用：\n\n\t>下面的图显示了导航控制器的流程。最左侧是根视图，当用户点击其中的General项时，General视图会滑入屏幕；当用户继续点击Auto-Lock项是，Auto-Lock视图将滑入屏幕。相应地，在对象管理上，导航控制器使用了导航堆栈。根视图控制器在堆栈最底层，接下来入栈的是General视图控制器和Auto-Lock视图控制器。可以调用pushViewControllerAnimated:方法将视图控制器推入栈顶，也可以调用popViewControllerAnimated:方法将视图控制器弹出堆栈。\n\n\t![image](/images/UINavigationVC/1.png)\n\n2. UINavigationController的结构组成\n\n\t看下图，UINavigationController有Navigation bar，Navigation View，Navigation toolbar等组成。\n\t\n\t![image](/images/UINavigationVC/2.png)\n\t\n\t现在我们建立一个例子，看看如何使用UINavigationController\n\t\n3. 新建一个项目\n\n\t命名为UINavigationControllerDemo，为了更好理解UINavigationController，我们选择Empty Application模板\n\t\n\t![image](/images/UINavigationVC/3.png)\n\t\n4. 创建一个View Controller，命名为RootViewController:依次选择File-New-New File，默认勾上WithXIB for user interface\n\n\t![image](/images/UINavigationVC/4.png)\n\t选择正确位置创建完成，这时项目里多了三个文件，分别是RootViewController.h RootViewController.m RootViewController.xib文件。\n\t打开RootViewController.xib，添加一个按钮控件，按钮Button改成：Goto SecondView，为跳转作准备\n\t\n\t![image](/images/UINavigationVC/5.png)\n\n5. 打开AppDelegate.h，向其中添加属性：\n\n\t>@property(strong, nonatomic)  UINavigationController *navController;\n\t\n\t添加后AppDelegate.h文件代码如下：\n\t\n\t```\n\t#import <UIKit/UIKit.h>\n\n\t@class ViewController;\n\n\t@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n\t@property (strong, nonatomic) UIWindow *window;\n\n\t@property (strong, nonatomic) ViewController *viewController;\n\n\t@property (strong, nonatomic) UINavigationController *navController;\n\n\t@end\n\t```\n\n6. 在AppDelegate.m文件的didFinishLaunchingWithOptions方法中创建添加navController，RootViewController视图。\n\n\t```\n\t- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n\t{\n\t    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n\t    RootViewController *rootView = [[RootViewController alloc] init];\n\t    rootView.title = @\"Root View\";\n\t    \n\t    self.navController = [[UINavigationController alloc] init];\n\t    [self.navController pushViewController:rootView animated:YES];\n\t    [self.window addSubview:self.navController.view];\n\t    [self.window makeKeyAndVisible];\n\t    return YES;\n\t}\n\t```\n\t给rootView的title命名为RootView，好识别View直接的切换关系。用pushViewController把rootView加入到navController的视图栈中。\n\n7. 现在Root视图添加完成\n\n\t看看效果：\n\t![image](/images/UINavigationVC/6.png)\n\t现在还没有Navigation bar。只有title\n\n8. 添加UIBarButtonItem\n\n\tbar ButtonItem分左右UIBarButtonItem。我们把左右的都添加上去。\n\t在RootViewController.m中添加代码如下：\n\t\n\t```\n\t- (void)viewDidLoad\n\t{\n\t    [super viewDidLoad];\n\t\n\t    UIBarButtonItem *leftButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAction target:self action:@selector(selectLeftAction:)];\n\t    self.navigationItem.leftBarButtonItem = leftButton;\n\t    \n\t    UIBarButtonItem *rightButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAdd  target:self action:@selector(selectRightAction:)];\n\t    self.navigationItem.rightBarButtonItem = rightButton;<p class=\"p1\">}</p>\n\t```\n\n\t这样添加了UIBarButtonItem了，效果如下：\n\t![image](/images/UINavigationVC/7.png)\n\n\t这里重点介绍下：\n\t\n\t\tUIBarButtonItem *leftButton = [UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAction target:self Actin:@@selector(selectLeftAction:)];\n\tUIBarButtonSystemItemAction的风格，这时系统自带的按钮风格，看下图，你不用一个个实验，你也知道想用的那个Item，如下图：\n\t![image](/images/UINavigationVC/8.png)\n\n9. 响应UIBarButtonItem的事件的实现\n\n\t我们在action：@selector（selectLeftAction:）;\n\taction添加了SelectLeftAction和selectRightAction在RootViewController.m文件中添加代码实现：\n\t\n\t```\n\t-(void)selectLeftAction:(id)sender\n\t{\n\t    UIAlertView *alter = [[UIAlertView alloc] initWithTitle:@\"提示\" message:@\"你点击了导航栏左按钮\" delegate:self  cancelButtonTitle:@\"确定\" otherButtonTitles:nil, nil];\n\t    [alter show];\n\t}\n\t\n\t-(void)selectRightAction:(id)sender\n\t{\n\t    UIAlertView *alter = [[UIAlertView alloc] initWithTitle:@\"提示\" message:@\"你点击了导航栏右按钮\" delegate:self  cancelButtonTitle:@\"确定\" otherButtonTitles:nil, nil];\n\t    [alter show];\n\t}\n\t```\n\n\t这样在点击左右的UIBarButtonItem时，弹出提示：\n\t![image](/images/UINavigationVC/9.png)\n\n\t本篇先到UIBarButtonItem，下篇讲解页面跳转与ToolBar\n","source":"_posts/UINavigationController详解与使用（一）添加UIButtonItem.md","raw":"title: \"UINavigationController详解与使用（一）添加UIButtonItem\"\ndate: 2014-04-17 16:39:03\ntags: NavController-UIButtonItem\n---\n\n####UINavigationController导航控制器如何使用\n\n1. UINavigationController可以翻译为导航控制器，在iOS里经常用到。\n\n\t我们看看它如何使用：\n\n\t>下面的图显示了导航控制器的流程。最左侧是根视图，当用户点击其中的General项时，General视图会滑入屏幕；当用户继续点击Auto-Lock项是，Auto-Lock视图将滑入屏幕。相应地，在对象管理上，导航控制器使用了导航堆栈。根视图控制器在堆栈最底层，接下来入栈的是General视图控制器和Auto-Lock视图控制器。可以调用pushViewControllerAnimated:方法将视图控制器推入栈顶，也可以调用popViewControllerAnimated:方法将视图控制器弹出堆栈。\n\n\t![image](/images/UINavigationVC/1.png)\n\n2. UINavigationController的结构组成\n\n\t看下图，UINavigationController有Navigation bar，Navigation View，Navigation toolbar等组成。\n\t\n\t![image](/images/UINavigationVC/2.png)\n\t\n\t现在我们建立一个例子，看看如何使用UINavigationController\n\t\n3. 新建一个项目\n\n\t命名为UINavigationControllerDemo，为了更好理解UINavigationController，我们选择Empty Application模板\n\t\n\t![image](/images/UINavigationVC/3.png)\n\t\n4. 创建一个View Controller，命名为RootViewController:依次选择File-New-New File，默认勾上WithXIB for user interface\n\n\t![image](/images/UINavigationVC/4.png)\n\t选择正确位置创建完成，这时项目里多了三个文件，分别是RootViewController.h RootViewController.m RootViewController.xib文件。\n\t打开RootViewController.xib，添加一个按钮控件，按钮Button改成：Goto SecondView，为跳转作准备\n\t\n\t![image](/images/UINavigationVC/5.png)\n\n5. 打开AppDelegate.h，向其中添加属性：\n\n\t>@property(strong, nonatomic)  UINavigationController *navController;\n\t\n\t添加后AppDelegate.h文件代码如下：\n\t\n\t```\n\t#import <UIKit/UIKit.h>\n\n\t@class ViewController;\n\n\t@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n\t@property (strong, nonatomic) UIWindow *window;\n\n\t@property (strong, nonatomic) ViewController *viewController;\n\n\t@property (strong, nonatomic) UINavigationController *navController;\n\n\t@end\n\t```\n\n6. 在AppDelegate.m文件的didFinishLaunchingWithOptions方法中创建添加navController，RootViewController视图。\n\n\t```\n\t- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n\t{\n\t    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\n\t    RootViewController *rootView = [[RootViewController alloc] init];\n\t    rootView.title = @\"Root View\";\n\t    \n\t    self.navController = [[UINavigationController alloc] init];\n\t    [self.navController pushViewController:rootView animated:YES];\n\t    [self.window addSubview:self.navController.view];\n\t    [self.window makeKeyAndVisible];\n\t    return YES;\n\t}\n\t```\n\t给rootView的title命名为RootView，好识别View直接的切换关系。用pushViewController把rootView加入到navController的视图栈中。\n\n7. 现在Root视图添加完成\n\n\t看看效果：\n\t![image](/images/UINavigationVC/6.png)\n\t现在还没有Navigation bar。只有title\n\n8. 添加UIBarButtonItem\n\n\tbar ButtonItem分左右UIBarButtonItem。我们把左右的都添加上去。\n\t在RootViewController.m中添加代码如下：\n\t\n\t```\n\t- (void)viewDidLoad\n\t{\n\t    [super viewDidLoad];\n\t\n\t    UIBarButtonItem *leftButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAction target:self action:@selector(selectLeftAction:)];\n\t    self.navigationItem.leftBarButtonItem = leftButton;\n\t    \n\t    UIBarButtonItem *rightButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAdd  target:self action:@selector(selectRightAction:)];\n\t    self.navigationItem.rightBarButtonItem = rightButton;<p class=\"p1\">}</p>\n\t```\n\n\t这样添加了UIBarButtonItem了，效果如下：\n\t![image](/images/UINavigationVC/7.png)\n\n\t这里重点介绍下：\n\t\n\t\tUIBarButtonItem *leftButton = [UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAction target:self Actin:@@selector(selectLeftAction:)];\n\tUIBarButtonSystemItemAction的风格，这时系统自带的按钮风格，看下图，你不用一个个实验，你也知道想用的那个Item，如下图：\n\t![image](/images/UINavigationVC/8.png)\n\n9. 响应UIBarButtonItem的事件的实现\n\n\t我们在action：@selector（selectLeftAction:）;\n\taction添加了SelectLeftAction和selectRightAction在RootViewController.m文件中添加代码实现：\n\t\n\t```\n\t-(void)selectLeftAction:(id)sender\n\t{\n\t    UIAlertView *alter = [[UIAlertView alloc] initWithTitle:@\"提示\" message:@\"你点击了导航栏左按钮\" delegate:self  cancelButtonTitle:@\"确定\" otherButtonTitles:nil, nil];\n\t    [alter show];\n\t}\n\t\n\t-(void)selectRightAction:(id)sender\n\t{\n\t    UIAlertView *alter = [[UIAlertView alloc] initWithTitle:@\"提示\" message:@\"你点击了导航栏右按钮\" delegate:self  cancelButtonTitle:@\"确定\" otherButtonTitles:nil, nil];\n\t    [alter show];\n\t}\n\t```\n\n\t这样在点击左右的UIBarButtonItem时，弹出提示：\n\t![image](/images/UINavigationVC/9.png)\n\n\t本篇先到UIBarButtonItem，下篇讲解页面跳转与ToolBar\n","slug":"UINavigationController详解与使用（一）添加UIButtonItem","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid206000x3rtc45a0rcby"},{"title":"UIButton控件设置","date":"2014-04-22T08:55:43.000Z","_content":"\n1. 创建UIButton对象\n\n\tUIButton *bt = [[UIButton alloc]init];\n\t\n2. 隐藏UIButton\n\n\tbt.hidden=YES;//此时按钮被隐藏\n\tbt.hidden=NO;//此时按钮被显示在视图中\n   \n3. 设置UIButton的坐标和大小\n\n\t[bt setFrame:CGRectMake(100, 100, 100, 40)];\n\t\n4. 设置UIButton的颜色\n\n\t[bt setBackgroundColor:[UIColor redColor]]\n\t\n5. 设置UIButton的标题字，forState设置的时按钮的当前状态，此时为正常状态\n\n\t[bt setTitle:@\"aaa\" forState:UIControlStateNormal];\n\t\n\tUIButton的各种状态\n>\t正常状态 UIControlStateNormal;\n>\t高亮状态 UIControlStateHighlighted;\n>\t禁用状态UIControlStateDisabled；\n>\t选中状态 UIControlStateSelected;\n>\t代理状态 UIControlStateApplication;\n>\t保留状态 UIControlStateReserved;\n\n6. 设置UIButton在正常状态下的字体颜色\n\n\t[bt setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];","source":"_posts/UIButton控件设置.md","raw":"title: \"UIButton控件设置\"\ndate: 2014-04-22 16:55:43\ntags: UIButton\n---\n\n1. 创建UIButton对象\n\n\tUIButton *bt = [[UIButton alloc]init];\n\t\n2. 隐藏UIButton\n\n\tbt.hidden=YES;//此时按钮被隐藏\n\tbt.hidden=NO;//此时按钮被显示在视图中\n   \n3. 设置UIButton的坐标和大小\n\n\t[bt setFrame:CGRectMake(100, 100, 100, 40)];\n\t\n4. 设置UIButton的颜色\n\n\t[bt setBackgroundColor:[UIColor redColor]]\n\t\n5. 设置UIButton的标题字，forState设置的时按钮的当前状态，此时为正常状态\n\n\t[bt setTitle:@\"aaa\" forState:UIControlStateNormal];\n\t\n\tUIButton的各种状态\n>\t正常状态 UIControlStateNormal;\n>\t高亮状态 UIControlStateHighlighted;\n>\t禁用状态UIControlStateDisabled；\n>\t选中状态 UIControlStateSelected;\n>\t代理状态 UIControlStateApplication;\n>\t保留状态 UIControlStateReserved;\n\n6. 设置UIButton在正常状态下的字体颜色\n\n\t[bt setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];","slug":"UIButton控件设置","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid20800103rtcauln6hgt"},{"title":"SVN常用命令集合","date":"2014-07-04T01:16:36.000Z","_content":"\n1. SVN常用命令集\n\n\t> svn info 查询svn根目录的信息，这个命令当你想知道某个svn目录是从哪个服务器上下来的时候特别有效\n\t> svn add 增加一个文件到根目录里，注意要用svn commit上传这个修改\n\t> svn status 查询当前目录下文件修改的情况，a表示增加，M表示修改\n\t> svn diff 查看本目录下所有的文件有哪些区别，当然可以指定到文件名\n\t> svn commit -m \"fix bug\" file上传某个文件的修改，并增加注释\n\t> svn ci 上传所有的修改，会提示你添加修改记录\n\t> svn log file 查询某个文件的修改记录\n\t> svn checkout 从svn服务器上去一个目录，带svn信息\n \t> svn export 从svn服务器上取出一个目录，仅源文件，没有讨厌的.svn信息\n \t> svn revert 回滚本地所有的未上传的所有修改，慎用，回复该本地所有的修改操作。可一次回滚一个目录或者文件\n \t> svn revert file --depth=infinity 回滚该目录下的所有文件\n \t> svn diff -r3 rules.txt 将本地的working目录下的文件和服务器的r3版本之间进行比较\n \t> svn diff -r 3:2 rules.txt 比较服务器上得r2版本和r3版本\t","source":"_posts/SVN常用命令集合.md","raw":"title: \"SVN常用命令集合\"\ndate: 2014-07-04 09:16:36\ntags: SVN\n---\n\n1. SVN常用命令集\n\n\t> svn info 查询svn根目录的信息，这个命令当你想知道某个svn目录是从哪个服务器上下来的时候特别有效\n\t> svn add 增加一个文件到根目录里，注意要用svn commit上传这个修改\n\t> svn status 查询当前目录下文件修改的情况，a表示增加，M表示修改\n\t> svn diff 查看本目录下所有的文件有哪些区别，当然可以指定到文件名\n\t> svn commit -m \"fix bug\" file上传某个文件的修改，并增加注释\n\t> svn ci 上传所有的修改，会提示你添加修改记录\n\t> svn log file 查询某个文件的修改记录\n\t> svn checkout 从svn服务器上去一个目录，带svn信息\n \t> svn export 从svn服务器上取出一个目录，仅源文件，没有讨厌的.svn信息\n \t> svn revert 回滚本地所有的未上传的所有修改，慎用，回复该本地所有的修改操作。可一次回滚一个目录或者文件\n \t> svn revert file --depth=infinity 回滚该目录下的所有文件\n \t> svn diff -r3 rules.txt 将本地的working目录下的文件和服务器的r3版本之间进行比较\n \t> svn diff -r 3:2 rules.txt 比较服务器上得r2版本和r3版本\t","slug":"SVN常用命令集合","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid20a00133rtc4xw05pjw"},{"title":"OC数组排序","date":"2014-07-21T05:47:56.000Z","_content":"\n> 大体上，OC中常用的数组排序有以下几种方法：\n> sortedArrayUsingSelector:   \n> sortedArrayUsingComparator:   \n> sortedArrayUsingDescriptors:\n\n###简单排序（sortedArrayUsingSelector:）\n\n1. 简单排序\n\n\t如果只是对字符串的排序，可以利用sortedArrayUsingSelector:方法就可以了，代码如下：\n\t\n\t```\n\t//简单排序\n\tvoid sortArray1(){\n    NSArray *array = [NSArray arrayWithObjects:@\"abc\",@\"456\",@\"123\",@\"789\",@\"ef\", nil];\n    NSArray *sortedArray = [array sortedArrayUsingSelector:@selector(compare:)];\n    NSLog(@\"排序后:%@\",sortedArray);\n\t}\n\t```\n\t除了字符串自带的compare:方法，也可以自己写compare:方法，进行对象的比较；如下：\n\t   \n\t首先是新建了Person类，实现方法如下：\n\t\n\t```\n\t#import \"Person.h\"\n\t@implementation Person\n\t//直接实现静态方法，获取带有name和age的Person对象\n\t+(Person *)personWithAge:(int) age withName:(NSString *)name{\n    Person *person = [[Person alloc] init];\n    person.age = age;\n    person.name = name;\n    return person;\n\t}\n \n\t//自定义排序方法\n\t-(NSComparisonResult)comparePerson:(Person *)person{\n  //默认按年龄排序\n    NSComparisonResult result = [[NSNumber numberWithInt:person.age] compare:[NSNumber numberWithInt:self.age]];//注意:基本数据类型要进行数据转换\n  //如果年龄一样，就按照名字排序\n    if (result == NSOrderedSame) {\n        result = [self.name compare:person.name];\n    }\n    return result;\n\t}\n\t@end\n\t```\n\t主函数代码如下：\n\t```\nvoid sortArray2(){\n    Person *p1 = [Person personWithAge:23 withName:@\"zhangsan\"];\n    Person *p2 = [Person personWithAge:21 withName:@\"lisi\"];\n    Person *p3 = [Person personWithAge:24 withName:@\"wangwu\"];\n    Person *p4 = [Person personWithAge:24 withName:@\"liwu\"];\n    Person *p5 = [Person personWithAge:20 withName:@\"liwu\"];\n    NSArray *array = [NSArray arrayWithObjects:p1,p2,p3,p4,p5, nil];\n    NSArray *sortedArray = [array sortedArrayUsingSelector:@selector(comparePerson:)];\n    NSLog(@\"排序后:%@\",sortedArray);\n}\n\t```\n2. 利用block语法（sortedArrayUsingComparator:）\n\n\t苹果官方提供了block语法，比较方便。其中数组排序可以用sortedArrayUsingComparator:方法，代码如下：\n\t\n\t```\nvoid sortArray3(){\n    NSArray *array = [NSArray arrayWithObjects:@\"1bc\",@\"4b6\",@\"123\",@\"789\",@\"3ef\", nil];\n    NSArray *sortedArray = [array sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) {\n \n   //这里的代码可以参照上面compare:默认的排序方法，也可以把自定义的方法写在这里，给对象排序\n        NSComparisonResult result = [obj1 compare:obj2];\n        return result;\n    }];\n    NSLog(@\"排序后:%@\",sortedArray);\n}\n\t```\n3. 高级排序（sortedArrayUsingDescriptors:）\n\n\tPerson类里面有另外一个类的变量，比如说Person类除了name，age变量，还有一辆车Car类型，Car类里面有个name属性。对Person对象进行排序，有这样的要求：按照Car的name排序，如果是同一辆车，也就是Car的name相同，name再按照年龄进行排序，如果年龄也相同，最后按照Person的name进行排序。\n\t\n\t上面这样就要使用第三种方法，利用排序描述其，不过说，看API介绍。如下：\n\t首先写个Car类，实现类Car.m代码如下：\n\t\n\t```\n#import \"Car.h\"\n@implementation Car\n \n+(Car *)initWithName:(NSString *)name{\n    Car *car = [Car alloc] init];\n    car.name = name;\n    return car;\n}\n \n@end\n\t```\n\t然后改写Person类，实现类Person.m代码如下：\n\t\n\t```\n#import \"Person.h\"\n#import \"Car.h\"\n@implementation Person\n \n+(Person *)personWithAge:(int)age withName:(NSString *)name withCar:(Car *)car{\n    Person *person = [[Person alloc] init];\n    person.age = age;\n    person.name = name;\n    person.car = car;\n    return person;\n}\n \n//这里重写description方法，用于最后测试排序结果显示\n-(NSString *)description{\n    return [NSString stringWithFormat:@\"age is %zi , name is %@, car is %@\",_age,_name,_car.name];\n}\n \n@end\n\t```\n\t主函数代码如下：\n\t\n\t```\nvoid sortArray4(){\n        //首先来3辆车，分别是奥迪、劳斯莱斯、宝马\n        Car *car1 = [Car initWithName:@\"Audio\"];\n        Car *car2 = [Car initWithName:@\"Rolls-Royce\"];\n        Car *car3 = [Car initWithName:@\"BMW\"];\n         \n        //再来5个Person，每人送辆车，分别为car2、car1、car1、car3、car2\n        Person *p1 = [Person personWithAge:23 withName:@\"zhangsan\" withCar:car2];\n        Person *p2 = [Person personWithAge:21 withName:@\"zhangsan\" withCar:car1];\n        Person *p3 = [Person personWithAge:24 withName:@\"lisi\" withCar:car1];\n        Person *p4 = [Person personWithAge:23 withName:@\"wangwu\" withCar:car3];\n        Person *p5 = [Person personWithAge:23 withName:@\"wangwu\" withCar:car2];\n \n     \n        //加入数组\n        NSArray *array = [NSArray arrayWithObjects:p1,p2,p3,p4,p5, nil];\n         \n        //构建排序描述器\n        NSSortDescriptor *carNameDesc = [NSSortDescriptor sortDescriptorWithKey:@\"car.name\" ascending:YES];\n        NSSortDescriptor *personNameDesc = [NSSortDescriptor sortDescriptorWithKey:@\"name\" ascending:YES];\n        NSSortDescriptor *personAgeDesc = [NSSortDescriptor sortDescriptorWithKey:@\"age\" ascending:YES];\n         \n        //把排序描述器放进数组里，放入的顺序就是你想要排序的顺序\n        //我这里是：首先按照年龄排序，然后是车的名字，最后是按照人的名字\n        NSArray *descriptorArray = [NSArray arrayWithObjects:personAgeDesc,carNameDesc,personNameDesc, nil];\n         \n        NSArray *sortedArray = [array sortedArrayUsingDescriptors: descriptorArray];\n        NSLog(@\"%@\",sortedArray);\n}\n\t```\n\t结果如下：\n\t![image](/images/数组排序/20150721.png)","source":"_posts/OC数组排序.md","raw":"title: \"OC数组排序\"\ndate: 2014-07-21 13:47:56\ntags: 数组排序\n---\n\n> 大体上，OC中常用的数组排序有以下几种方法：\n> sortedArrayUsingSelector:   \n> sortedArrayUsingComparator:   \n> sortedArrayUsingDescriptors:\n\n###简单排序（sortedArrayUsingSelector:）\n\n1. 简单排序\n\n\t如果只是对字符串的排序，可以利用sortedArrayUsingSelector:方法就可以了，代码如下：\n\t\n\t```\n\t//简单排序\n\tvoid sortArray1(){\n    NSArray *array = [NSArray arrayWithObjects:@\"abc\",@\"456\",@\"123\",@\"789\",@\"ef\", nil];\n    NSArray *sortedArray = [array sortedArrayUsingSelector:@selector(compare:)];\n    NSLog(@\"排序后:%@\",sortedArray);\n\t}\n\t```\n\t除了字符串自带的compare:方法，也可以自己写compare:方法，进行对象的比较；如下：\n\t   \n\t首先是新建了Person类，实现方法如下：\n\t\n\t```\n\t#import \"Person.h\"\n\t@implementation Person\n\t//直接实现静态方法，获取带有name和age的Person对象\n\t+(Person *)personWithAge:(int) age withName:(NSString *)name{\n    Person *person = [[Person alloc] init];\n    person.age = age;\n    person.name = name;\n    return person;\n\t}\n \n\t//自定义排序方法\n\t-(NSComparisonResult)comparePerson:(Person *)person{\n  //默认按年龄排序\n    NSComparisonResult result = [[NSNumber numberWithInt:person.age] compare:[NSNumber numberWithInt:self.age]];//注意:基本数据类型要进行数据转换\n  //如果年龄一样，就按照名字排序\n    if (result == NSOrderedSame) {\n        result = [self.name compare:person.name];\n    }\n    return result;\n\t}\n\t@end\n\t```\n\t主函数代码如下：\n\t```\nvoid sortArray2(){\n    Person *p1 = [Person personWithAge:23 withName:@\"zhangsan\"];\n    Person *p2 = [Person personWithAge:21 withName:@\"lisi\"];\n    Person *p3 = [Person personWithAge:24 withName:@\"wangwu\"];\n    Person *p4 = [Person personWithAge:24 withName:@\"liwu\"];\n    Person *p5 = [Person personWithAge:20 withName:@\"liwu\"];\n    NSArray *array = [NSArray arrayWithObjects:p1,p2,p3,p4,p5, nil];\n    NSArray *sortedArray = [array sortedArrayUsingSelector:@selector(comparePerson:)];\n    NSLog(@\"排序后:%@\",sortedArray);\n}\n\t```\n2. 利用block语法（sortedArrayUsingComparator:）\n\n\t苹果官方提供了block语法，比较方便。其中数组排序可以用sortedArrayUsingComparator:方法，代码如下：\n\t\n\t```\nvoid sortArray3(){\n    NSArray *array = [NSArray arrayWithObjects:@\"1bc\",@\"4b6\",@\"123\",@\"789\",@\"3ef\", nil];\n    NSArray *sortedArray = [array sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) {\n \n   //这里的代码可以参照上面compare:默认的排序方法，也可以把自定义的方法写在这里，给对象排序\n        NSComparisonResult result = [obj1 compare:obj2];\n        return result;\n    }];\n    NSLog(@\"排序后:%@\",sortedArray);\n}\n\t```\n3. 高级排序（sortedArrayUsingDescriptors:）\n\n\tPerson类里面有另外一个类的变量，比如说Person类除了name，age变量，还有一辆车Car类型，Car类里面有个name属性。对Person对象进行排序，有这样的要求：按照Car的name排序，如果是同一辆车，也就是Car的name相同，name再按照年龄进行排序，如果年龄也相同，最后按照Person的name进行排序。\n\t\n\t上面这样就要使用第三种方法，利用排序描述其，不过说，看API介绍。如下：\n\t首先写个Car类，实现类Car.m代码如下：\n\t\n\t```\n#import \"Car.h\"\n@implementation Car\n \n+(Car *)initWithName:(NSString *)name{\n    Car *car = [Car alloc] init];\n    car.name = name;\n    return car;\n}\n \n@end\n\t```\n\t然后改写Person类，实现类Person.m代码如下：\n\t\n\t```\n#import \"Person.h\"\n#import \"Car.h\"\n@implementation Person\n \n+(Person *)personWithAge:(int)age withName:(NSString *)name withCar:(Car *)car{\n    Person *person = [[Person alloc] init];\n    person.age = age;\n    person.name = name;\n    person.car = car;\n    return person;\n}\n \n//这里重写description方法，用于最后测试排序结果显示\n-(NSString *)description{\n    return [NSString stringWithFormat:@\"age is %zi , name is %@, car is %@\",_age,_name,_car.name];\n}\n \n@end\n\t```\n\t主函数代码如下：\n\t\n\t```\nvoid sortArray4(){\n        //首先来3辆车，分别是奥迪、劳斯莱斯、宝马\n        Car *car1 = [Car initWithName:@\"Audio\"];\n        Car *car2 = [Car initWithName:@\"Rolls-Royce\"];\n        Car *car3 = [Car initWithName:@\"BMW\"];\n         \n        //再来5个Person，每人送辆车，分别为car2、car1、car1、car3、car2\n        Person *p1 = [Person personWithAge:23 withName:@\"zhangsan\" withCar:car2];\n        Person *p2 = [Person personWithAge:21 withName:@\"zhangsan\" withCar:car1];\n        Person *p3 = [Person personWithAge:24 withName:@\"lisi\" withCar:car1];\n        Person *p4 = [Person personWithAge:23 withName:@\"wangwu\" withCar:car3];\n        Person *p5 = [Person personWithAge:23 withName:@\"wangwu\" withCar:car2];\n \n     \n        //加入数组\n        NSArray *array = [NSArray arrayWithObjects:p1,p2,p3,p4,p5, nil];\n         \n        //构建排序描述器\n        NSSortDescriptor *carNameDesc = [NSSortDescriptor sortDescriptorWithKey:@\"car.name\" ascending:YES];\n        NSSortDescriptor *personNameDesc = [NSSortDescriptor sortDescriptorWithKey:@\"name\" ascending:YES];\n        NSSortDescriptor *personAgeDesc = [NSSortDescriptor sortDescriptorWithKey:@\"age\" ascending:YES];\n         \n        //把排序描述器放进数组里，放入的顺序就是你想要排序的顺序\n        //我这里是：首先按照年龄排序，然后是车的名字，最后是按照人的名字\n        NSArray *descriptorArray = [NSArray arrayWithObjects:personAgeDesc,carNameDesc,personNameDesc, nil];\n         \n        NSArray *sortedArray = [array sortedArrayUsingDescriptors: descriptorArray];\n        NSLog(@\"%@\",sortedArray);\n}\n\t```\n\t结果如下：\n\t![image](/images/数组排序/20150721.png)","slug":"OC数组排序","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid20c00163rtcvltssny2"},{"title":"Hexo——搭建博客","date":"2014-03-10T15:43:59.000Z","_content":"\n###本地搭建hexo\n\n1. 安装nvm(node.js的版本管理工具）以下提供两种安装方法\n\t- cURL：\n\t\n\t```\n\t$ curl https://raw.githubusercontent.com/creationix/nvm/v0.24.1/install.sh | bash\n\t```\n\n\t- Wget:\n\t\n\t```\n\t$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.24.1/install.sh | bash\n\t```\n\n2. 安装完成后，重启终端并执行下列命令安装Node.js\n\t```\n\t$ nvm install 0.10\n\t```\n3. 添加如下内容到.zshrc配置文件\n\t\n\t```\n\t[ -s \"/Users/`users`/.nvm/nvm.sh\" ] && . \"/Users/`users`/.nvm/nvm.sh\" # This loads nvm\n\t```\n\t`注意：`“users”修改为你的家目录名\n\t\n4. 将nvm的bin目录添加到环境变量中\n\n\t```\n\t以zsh为例：\n\t1. 打开zsh配置文件\n\t\tvi ~/.zshrc\n\t2. 添加如下内容到.zshrc\n\t\texport PATH=$PATH:~/.nvm/v0.10.38/bin\n\t```\n5. 安装hexo\n\n\t```\n\t$ npm install -g hexo-cli\n\t```\n6. 创建hexo文件夹，并安装hexo相关组件\n\t\n\t```\n\t$ hexo init hexo\n\t$ cd hexo\n\t$ npm install\n\t```\n7. 本地查看\n\t输入如下命令后，打开浏览器，并输入[localhost:4000](http://0.0.0.0:4000/)\n\t```\n\t$ hexo g\n\t$ hexo s\n\t```\n8. 部署的时候有时候会失败，可以安装hexo-deployer-git来解决\n\t```\n\t$ npm install hexo-deployer-git --save\n\t```\n\t\n###部署到github\n\n1. 注册github账号\n\n2. 创建github账号同名repository\n\t\n\t\teg:github账号名为leelovcy，则创建leelovcy.github.io\n\t\n3. 部署到github上\n\t\n\t如下所示编辑_config.yml\n\t\t\n\t\tdeploy:\n\t\t  type: git\n\t\t  repository: http://github.com/LeeLovCY/LeeLovCY.github.io.git\n\t\t  branch: master\n\t`注意：`上述冒号之后有空格\n4. 输入如下命令，完成到github得部署，之后打开浏览器并输入<LeeLovCY.github.io>来查看\n\n\t```\n\t$ hexo g\n\t$ hexo d\n\t```\n\t\n\t","source":"_posts/Hexo——搭建博客.md","raw":"title: \"Hexo——搭建博客\"\ndate: 2014-03-10 23:43:59\ntags: Hexo\n---\n\n###本地搭建hexo\n\n1. 安装nvm(node.js的版本管理工具）以下提供两种安装方法\n\t- cURL：\n\t\n\t```\n\t$ curl https://raw.githubusercontent.com/creationix/nvm/v0.24.1/install.sh | bash\n\t```\n\n\t- Wget:\n\t\n\t```\n\t$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.24.1/install.sh | bash\n\t```\n\n2. 安装完成后，重启终端并执行下列命令安装Node.js\n\t```\n\t$ nvm install 0.10\n\t```\n3. 添加如下内容到.zshrc配置文件\n\t\n\t```\n\t[ -s \"/Users/`users`/.nvm/nvm.sh\" ] && . \"/Users/`users`/.nvm/nvm.sh\" # This loads nvm\n\t```\n\t`注意：`“users”修改为你的家目录名\n\t\n4. 将nvm的bin目录添加到环境变量中\n\n\t```\n\t以zsh为例：\n\t1. 打开zsh配置文件\n\t\tvi ~/.zshrc\n\t2. 添加如下内容到.zshrc\n\t\texport PATH=$PATH:~/.nvm/v0.10.38/bin\n\t```\n5. 安装hexo\n\n\t```\n\t$ npm install -g hexo-cli\n\t```\n6. 创建hexo文件夹，并安装hexo相关组件\n\t\n\t```\n\t$ hexo init hexo\n\t$ cd hexo\n\t$ npm install\n\t```\n7. 本地查看\n\t输入如下命令后，打开浏览器，并输入[localhost:4000](http://0.0.0.0:4000/)\n\t```\n\t$ hexo g\n\t$ hexo s\n\t```\n8. 部署的时候有时候会失败，可以安装hexo-deployer-git来解决\n\t```\n\t$ npm install hexo-deployer-git --save\n\t```\n\t\n###部署到github\n\n1. 注册github账号\n\n2. 创建github账号同名repository\n\t\n\t\teg:github账号名为leelovcy，则创建leelovcy.github.io\n\t\n3. 部署到github上\n\t\n\t如下所示编辑_config.yml\n\t\t\n\t\tdeploy:\n\t\t  type: git\n\t\t  repository: http://github.com/LeeLovCY/LeeLovCY.github.io.git\n\t\t  branch: master\n\t`注意：`上述冒号之后有空格\n4. 输入如下命令，完成到github得部署，之后打开浏览器并输入<LeeLovCY.github.io>来查看\n\n\t```\n\t$ hexo g\n\t$ hexo d\n\t```\n\t\n\t","slug":"Hexo——搭建博客","published":1,"updated":"2016-01-16T01:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijgid20d00193rtccf441m0q"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cijgid1z800003rtcl8nh106i","tag_id":"cijgid1zd00013rtc4sstdcbn","_id":"cijgid1ze00023rtc3zqklf98"},{"post_id":"cijgid1zk00033rtc5svd3q36","tag_id":"cijgid1zl00043rtcgxzgcmcx","_id":"cijgid1zl00053rtc3xkx748a"},{"post_id":"cijgid1zm00063rtcr1g45qes","tag_id":"cijgid1zo00073rtcal01v4pu","_id":"cijgid1zo00083rtcl56yg781"},{"post_id":"cijgid1zp00093rtc8ix0gza4","tag_id":"cijgid1zq000a3rtcsg0h6ryi","_id":"cijgid1zr000b3rtcshlsexzx"},{"post_id":"cijgid1zr000c3rtcmg4z937v","tag_id":"cijgid1zs000d3rtclcyhuus2","_id":"cijgid1zt000e3rtcf7frn2jw"},{"post_id":"cijgid1zu000f3rtcfv7w07cg","tag_id":"cijgid1zv000g3rtcke8qgab8","_id":"cijgid1zv000h3rtcq6w5g3vg"},{"post_id":"cijgid1zw000i3rtcvj4gm3lo","tag_id":"cijgid1zx000j3rtclu68ta7b","_id":"cijgid1zx000k3rtcpljrf25c"},{"post_id":"cijgid1zy000l3rtc5jtkcpai","tag_id":"cijgid1zz000m3rtckd7z1t9w","_id":"cijgid1zz000n3rtc9yb3qt0i"},{"post_id":"cijgid200000o3rtc4fyrm3fu","tag_id":"cijgid201000p3rtc5zg6oex7","_id":"cijgid201000q3rtcdeqaa20p"},{"post_id":"cijgid202000r3rtc94a0jxry","tag_id":"cijgid203000s3rtc9ehci4is","_id":"cijgid203000t3rtc57h6e23n"},{"post_id":"cijgid204000u3rtcp7omuezc","tag_id":"cijgid205000v3rtco6w9cxjn","_id":"cijgid205000w3rtcz9nspfzd"},{"post_id":"cijgid206000x3rtc45a0rcby","tag_id":"cijgid207000y3rtchm8bddj1","_id":"cijgid208000z3rtc7v3qgtaa"},{"post_id":"cijgid20800103rtcauln6hgt","tag_id":"cijgid20900113rtcll3zpn6e","_id":"cijgid20900123rtci1eohto1"},{"post_id":"cijgid20a00133rtc4xw05pjw","tag_id":"cijgid20b00143rtc4svqisyo","_id":"cijgid20b00153rtcqgyndz71"},{"post_id":"cijgid20c00163rtcvltssny2","tag_id":"cijgid20d00173rtc3yew1684","_id":"cijgid20d00183rtcbi5zf0gp"},{"post_id":"cijgid20d00193rtccf441m0q","tag_id":"cijgid20f001a3rtcvwziygg7","_id":"cijgid20f001b3rtcr2srbx0m"}],"Tag":[{"name":"CocoaPods","_id":"cijgid1zd00013rtc4sstdcbn"},{"name":"面向对象思想","_id":"cijgid1zl00043rtcgxzgcmcx"},{"name":"故事一则","_id":"cijgid1zo00073rtcal01v4pu"},{"name":"手写Button设置","_id":"cijgid1zq000a3rtcsg0h6ryi"},{"name":"MD5加密","_id":"cijgid1zs000d3rtclcyhuus2"},{"name":"Quartz2D使用","_id":"cijgid1zv000g3rtcke8qgab8"},{"name":"viewController生命周期","_id":"cijgid1zx000j3rtclu68ta7b"},{"name":".Pch文件","_id":"cijgid1zz000m3rtckd7z1t9w"},{"name":"Xcode插件删除","_id":"cijgid201000p3rtc5zg6oex7"},{"name":"XML&JSON","_id":"cijgid203000s3rtc9ehci4is"},{"name":"ToolBar","_id":"cijgid205000v3rtco6w9cxjn"},{"name":"NavController-UIButtonItem","_id":"cijgid207000y3rtchm8bddj1"},{"name":"UIButton","_id":"cijgid20900113rtcll3zpn6e"},{"name":"SVN","_id":"cijgid20b00143rtc4svqisyo"},{"name":"数组排序","_id":"cijgid20d00173rtc3yew1684"},{"name":"Hexo","_id":"cijgid20f001a3rtcvwziygg7"}]}}